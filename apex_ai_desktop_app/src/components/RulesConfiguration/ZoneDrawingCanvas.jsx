/**\n * ZONE DRAWING CANVAS - INTERACTIVE GEOFENCING INTERFACE\n * =====================================================\n * Advanced HTML5 Canvas component for interactive geofencing zone creation\n * Features polygon drawing, point manipulation, real-time validation, and zone visualization\n * \n * Key Features:\n * - Interactive polygon drawing with mouse/touch support\n * - Point manipulation (drag, add, remove vertices)\n * - Real-time zone validation and visual feedback\n * - Multiple zone type styling and visualization\n * - Camera feed overlay integration\n * - Responsive coordinate system handling\n * - Professional UI with visual indicators\n */\n\nimport React, { useRef, useEffect, useState, useImperativeHandle, forwardRef, useCallback } from 'react';\nimport styled from 'styled-components';\nimport rulesConfigurationAPI from '../../services/RulesConfigurationAPI';\n\nconst CanvasContainer = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  background: ${props => props.theme.colors.backgroundLight};\n  border-radius: 8px;\n  overflow: hidden;\n  cursor: ${props => props.isDrawing ? 'crosshair' : 'default'};\n`;\n\nconst Canvas = styled.canvas`\n  width: 100%;\n  height: 100%;\n  display: block;\n`;\n\nconst ToolsOverlay = styled.div`\n  position: absolute;\n  top: 16px;\n  left: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n  z-index: 10;\n`;\n\nconst ToolButton = styled.button`\n  padding: 8px 12px;\n  background: ${props => props.active ? props.theme.colors.primary : 'rgba(0, 0, 0, 0.7)'};\n  color: ${props => props.active ? props.theme.colors.background : props.theme.colors.text};\n  border: 1px solid ${props => props.active ? props.theme.colors.primary : props.theme.colors.border};\n  border-radius: 6px;\n  font-size: 0.9rem;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all 0.3s ease;\n  backdrop-filter: blur(10px);\n  \n  &:hover {\n    background: ${props => props.active ? props.theme.colors.primaryDark : props.theme.colors.primary}20;\n    transform: translateY(-1px);\n  }\n  \n  &:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n  }\n`;\n\nconst InfoPanel = styled.div`\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  background: rgba(0, 0, 0, 0.8);\n  color: ${props => props.theme.colors.text};\n  padding: 12px 16px;\n  border-radius: 8px;\n  font-size: 0.9rem;\n  backdrop-filter: blur(10px);\n  border: 1px solid ${props => props.theme.colors.border};\n  z-index: 10;\n  max-width: 250px;\n`;\n\nconst StatusBar = styled.div`\n  position: absolute;\n  bottom: 16px;\n  left: 16px;\n  right: 16px;\n  background: rgba(0, 0, 0, 0.8);\n  color: ${props => props.theme.colors.text};\n  padding: 8px 16px;\n  border-radius: 6px;\n  font-size: 0.85rem;\n  backdrop-filter: blur(10px);\n  border: 1px solid ${props => props.theme.colors.border};\n  z-index: 10;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n`;\n\nconst ZoneTypeSelector = styled.select`\n  padding: 6px 10px;\n  background: rgba(0, 0, 0, 0.7);\n  color: ${props => props.theme.colors.text};\n  border: 1px solid ${props => props.theme.colors.border};\n  border-radius: 4px;\n  font-size: 0.85rem;\n  backdrop-filter: blur(10px);\n`;\n\n// Zone type colors for visual differentiation\nconst ZONE_COLORS = {\n  restricted: '#ff4444',\n  monitored: '#00ff88',\n  entry_exit: '#0080ff',\n  parking: '#ffaa00',\n  perimeter: '#ff8800',\n  sensitive: '#ff0080',\n  public: '#80ff00',\n  emergency: '#ff0000'\n};\n\n// Drawing modes\nconst DRAWING_MODES = {\n  SELECT: 'select',\n  DRAW: 'draw',\n  EDIT: 'edit'\n};\n\nconst ZoneDrawingCanvas = forwardRef(({\n  zones = [],\n  selectedZone,\n  isDrawingMode,\n  currentCamera,\n  onZoneCreated,\n  onZoneUpdated,\n  onZoneSelected,\n  onDrawingComplete\n}, ref) => {\n  \n  // Refs\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  \n  // State\n  const [drawingMode, setDrawingMode] = useState(DRAWING_MODES.SELECT);\n  const [currentPolygon, setCurrentPolygon] = useState([]);\n  const [selectedZoneType, setSelectedZoneType] = useState('monitored');\n  const [hoveredPoint, setHoveredPoint] = useState(null);\n  const [draggedPoint, setDraggedPoint] = useState(null);\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });\n  const [isPolygonValid, setIsPolygonValid] = useState(true);\n  const [validationMessage, setValidationMessage] = useState('');\n  \n  // Constants\n  const POINT_RADIUS = 6;\n  const HOVER_RADIUS = 10;\n  const MIN_POINTS = 3;\n  \n  // ========================================\n  // INITIALIZATION & LIFECYCLE\n  // ========================================\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    \n    if (!canvas || !container) return;\n    \n    const resizeCanvas = () => {\n      const rect = container.getBoundingClientRect();\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n      setCanvasSize({ width: rect.width, height: rect.height });\n      redrawCanvas();\n    };\n    \n    // Initial resize\n    resizeCanvas();\n    \n    // Setup resize observer\n    const resizeObserver = new ResizeObserver(resizeCanvas);\n    resizeObserver.observe(container);\n    \n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n  \n  useEffect(() => {\n    if (isDrawingMode) {\n      setDrawingMode(DRAWING_MODES.DRAW);\n      setCurrentPolygon([]);\n    } else {\n      setDrawingMode(DRAWING_MODES.SELECT);\n      setCurrentPolygon([]);\n    }\n  }, [isDrawingMode]);\n  \n  useEffect(() => {\n    redrawCanvas();\n  }, [zones, selectedZone, currentPolygon, hoveredPoint, canvasSize, selectedZoneType]);\n  \n  // ========================================\n  // COORDINATE CONVERSION\n  // ========================================\n  \n  const canvasToNormalized = useCallback((canvasX, canvasY) => {\n    return [\n      canvasX / canvasSize.width,\n      canvasY / canvasSize.height\n    ];\n  }, [canvasSize]);\n  \n  const normalizedToCanvas = useCallback((normalizedX, normalizedY) => {\n    return [\n      normalizedX * canvasSize.width,\n      normalizedY * canvasSize.height\n    ];\n  }, [canvasSize]);\n  \n  const getMousePos = useCallback((event) => {\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }, []);\n  \n  // ========================================\n  // POLYGON VALIDATION\n  // ========================================\n  \n  const validatePolygon = useCallback((points) => {\n    if (points.length < MIN_POINTS) {\n      setIsPolygonValid(false);\n      setValidationMessage(`Need at least ${MIN_POINTS} points`);\n      return false;\n    }\n    \n    // Check for self-intersection (basic check)\n    if (points.length >= 4) {\n      for (let i = 0; i < points.length; i++) {\n        const line1 = {\n          start: points[i],\n          end: points[(i + 1) % points.length]\n        };\n        \n        for (let j = i + 2; j < points.length - (i === 0 ? 1 : 0); j++) {\n          const line2 = {\n            start: points[j],\n            end: points[(j + 1) % points.length]\n          };\n          \n          if (linesIntersect(line1.start, line1.end, line2.start, line2.end)) {\n            setIsPolygonValid(false);\n            setValidationMessage('Polygon cannot intersect itself');\n            return false;\n          }\n        }\n      }\n    }\n    \n    // Check minimum area\n    const area = calculatePolygonArea(points);\n    if (area < 0.001) { // Very small area in normalized coordinates\n      setIsPolygonValid(false);\n      setValidationMessage('Polygon area too small');\n      return false;\n    }\n    \n    setIsPolygonValid(true);\n    setValidationMessage('');\n    return true;\n  }, []);\n  \n  const linesIntersect = (p1, p2, p3, p4) => {\n    const denom = (p4[1] - p3[1]) * (p2[0] - p1[0]) - (p4[0] - p3[0]) * (p2[1] - p1[1]);\n    if (denom === 0) return false; // Lines are parallel\n    \n    const ua = ((p4[0] - p3[0]) * (p1[1] - p3[1]) - (p4[1] - p3[1]) * (p1[0] - p3[0])) / denom;\n    const ub = ((p2[0] - p1[0]) * (p1[1] - p3[1]) - (p2[1] - p1[1]) * (p1[0] - p3[0])) / denom;\n    \n    return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;\n  };\n  \n  const calculatePolygonArea = (points) => {\n    if (points.length < 3) return 0;\n    \n    let area = 0;\n    for (let i = 0; i < points.length; i++) {\n      const j = (i + 1) % points.length;\n      area += points[i][0] * points[j][1];\n      area -= points[j][0] * points[i][1];\n    }\n    \n    return Math.abs(area) / 2;\n  };\n  \n  // ========================================\n  // POINT DETECTION\n  // ========================================\n  \n  const findNearestPoint = useCallback((mouseX, mouseY, searchRadius = HOVER_RADIUS) => {\n    // Check current polygon points\n    if (currentPolygon.length > 0) {\n      for (let i = 0; i < currentPolygon.length; i++) {\n        const [canvasX, canvasY] = normalizedToCanvas(currentPolygon[i][0], currentPolygon[i][1]);\n        const distance = Math.sqrt((mouseX - canvasX) ** 2 + (mouseY - canvasY) ** 2);\n        \n        if (distance <= searchRadius) {\n          return { type: 'current', pointIndex: i, distance };\n        }\n      }\n    }\n    \n    // Check selected zone points\n    if (selectedZone && selectedZone.polygon_points) {\n      for (let i = 0; i < selectedZone.polygon_points.length; i++) {\n        const [canvasX, canvasY] = normalizedToCanvas(\n          selectedZone.polygon_points[i][0], \n          selectedZone.polygon_points[i][1]\n        );\n        const distance = Math.sqrt((mouseX - canvasX) ** 2 + (mouseY - canvasY) ** 2);\n        \n        if (distance <= searchRadius) {\n          return { type: 'selected', pointIndex: i, distance };\n        }\n      }\n    }\n    \n    return null;\n  }, [currentPolygon, selectedZone, normalizedToCanvas]);\n  \n  const findZoneAtPoint = useCallback((mouseX, mouseY) => {\n    const normalizedPos = canvasToNormalized(mouseX, mouseY);\n    \n    // Check zones in reverse order (top to bottom)\n    for (let i = zones.length - 1; i >= 0; i--) {\n      const zone = zones[i];\n      if (isPointInPolygon(normalizedPos, zone.polygon_points)) {\n        return zone;\n      }\n    }\n    \n    return null;\n  }, [zones, canvasToNormalized]);\n  \n  const isPointInPolygon = (point, polygon) => {\n    const [x, y] = point;\n    let inside = false;\n    \n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const [xi, yi] = polygon[i];\n      const [xj, yj] = polygon[j];\n      \n      if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n        inside = !inside;\n      }\n    }\n    \n    return inside;\n  };\n  \n  // ========================================\n  // DRAWING & RENDERING\n  // ========================================\n  \n  const redrawCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw background grid\n    drawGrid(ctx);\n    \n    // Draw existing zones\n    zones.forEach(zone => {\n      drawZone(ctx, zone, zone.zone_id === selectedZone?.zone_id);\n    });\n    \n    // Draw current polygon being drawn\n    if (currentPolygon.length > 0) {\n      drawCurrentPolygon(ctx);\n    }\n    \n    // Draw hover indicators\n    if (hoveredPoint) {\n      drawHoverIndicator(ctx, hoveredPoint);\n    }\n  }, [zones, selectedZone, currentPolygon, hoveredPoint, canvasSize]);\n  \n  const drawGrid = (ctx) => {\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n    ctx.lineWidth = 1;\n    \n    const gridSize = 50;\n    \n    // Vertical lines\n    for (let x = 0; x <= canvasSize.width; x += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, canvasSize.height);\n      ctx.stroke();\n    }\n    \n    // Horizontal lines\n    for (let y = 0; y <= canvasSize.height; y += gridSize) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(canvasSize.width, y);\n      ctx.stroke();\n    }\n  };\n  \n  const drawZone = (ctx, zone, isSelected) => {\n    if (!zone.polygon_points || zone.polygon_points.length < 2) return;\n    \n    const color = ZONE_COLORS[zone.zone_type] || ZONE_COLORS.monitored;\n    const alpha = isSelected ? '60' : '30';\n    \n    // Draw filled polygon\n    ctx.fillStyle = color + alpha;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = isSelected ? 3 : 2;\n    \n    ctx.beginPath();\n    zone.polygon_points.forEach((point, index) => {\n      const [canvasX, canvasY] = normalizedToCanvas(point[0], point[1]);\n      if (index === 0) {\n        ctx.moveTo(canvasX, canvasY);\n      } else {\n        ctx.lineTo(canvasX, canvasY);\n      }\n    });\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    \n    // Draw points if selected\n    if (isSelected) {\n      zone.polygon_points.forEach((point, index) => {\n        const [canvasX, canvasY] = normalizedToCanvas(point[0], point[1]);\n        drawPoint(ctx, canvasX, canvasY, color, true);\n      });\n    }\n    \n    // Draw zone label\n    if (zone.polygon_points.length > 0) {\n      const centerX = zone.polygon_points.reduce((sum, p) => sum + p[0], 0) / zone.polygon_points.length;\n      const centerY = zone.polygon_points.reduce((sum, p) => sum + p[1], 0) / zone.polygon_points.length;\n      const [labelX, labelY] = normalizedToCanvas(centerX, centerY);\n      \n      ctx.fillStyle = '#ffffff';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      \n      // Draw background for text\n      const textMetrics = ctx.measureText(zone.name);\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      ctx.fillRect(\n        labelX - textMetrics.width / 2 - 4,\n        labelY - 8,\n        textMetrics.width + 8,\n        16\n      );\n      \n      ctx.fillStyle = '#ffffff';\n      ctx.fillText(zone.name, labelX, labelY);\n    }\n  };\n  \n  const drawCurrentPolygon = (ctx) => {\n    if (currentPolygon.length === 0) return;\n    \n    const color = ZONE_COLORS[selectedZoneType];\n    const alpha = isPolygonValid ? '40' : '20';\n    \n    // Draw polygon lines\n    ctx.strokeStyle = isPolygonValid ? color : '#ff4444';\n    ctx.lineWidth = 2;\n    ctx.setLineDash([5, 5]);\n    \n    ctx.beginPath();\n    currentPolygon.forEach((point, index) => {\n      const [canvasX, canvasY] = normalizedToCanvas(point[0], point[1]);\n      if (index === 0) {\n        ctx.moveTo(canvasX, canvasY);\n      } else {\n        ctx.lineTo(canvasX, canvasY);\n      }\n    });\n    \n    // Close polygon if we have enough points\n    if (currentPolygon.length >= MIN_POINTS) {\n      ctx.closePath();\n      ctx.fillStyle = color + alpha;\n      ctx.fill();\n    }\n    \n    ctx.stroke();\n    ctx.setLineDash([]);\n    \n    // Draw points\n    currentPolygon.forEach((point, index) => {\n      const [canvasX, canvasY] = normalizedToCanvas(point[0], point[1]);\n      drawPoint(ctx, canvasX, canvasY, color, false);\n      \n      // Draw point number\n      ctx.fillStyle = '#ffffff';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText((index + 1).toString(), canvasX, canvasY);\n    });\n    \n    // Draw line to mouse position if drawing\n    if (drawingMode === DRAWING_MODES.DRAW && currentPolygon.length > 0) {\n      const lastPoint = currentPolygon[currentPolygon.length - 1];\n      const [lastX, lastY] = normalizedToCanvas(lastPoint[0], lastPoint[1]);\n      \n      ctx.strokeStyle = color + '80';\n      ctx.lineWidth = 1;\n      ctx.setLineDash([3, 3]);\n      ctx.beginPath();\n      ctx.moveTo(lastX, lastY);\n      ctx.lineTo(mousePosition.x, mousePosition.y);\n      ctx.stroke();\n      ctx.setLineDash([]);\n    }\n  };\n  \n  const drawPoint = (ctx, x, y, color, filled) => {\n    ctx.fillStyle = filled ? color : '#ffffff';\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    \n    ctx.beginPath();\n    ctx.arc(x, y, POINT_RADIUS, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n  };\n  \n  const drawHoverIndicator = (ctx, hoverInfo) => {\n    if (!hoverInfo) return;\n    \n    let canvasX, canvasY;\n    \n    if (hoverInfo.type === 'current') {\n      [canvasX, canvasY] = normalizedToCanvas(\n        currentPolygon[hoverInfo.pointIndex][0],\n        currentPolygon[hoverInfo.pointIndex][1]\n      );\n    } else if (hoverInfo.type === 'selected' && selectedZone) {\n      [canvasX, canvasY] = normalizedToCanvas(\n        selectedZone.polygon_points[hoverInfo.pointIndex][0],\n        selectedZone.polygon_points[hoverInfo.pointIndex][1]\n      );\n    } else {\n      return;\n    }\n    \n    // Draw hover ring\n    ctx.strokeStyle = '#ffffff';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(canvasX, canvasY, HOVER_RADIUS, 0, 2 * Math.PI);\n    ctx.stroke();\n  };\n  \n  // ========================================\n  // EVENT HANDLERS\n  // ========================================\n  \n  const handleMouseMove = useCallback((event) => {\n    const mousePos = getMousePos(event);\n    setMousePosition(mousePos);\n    \n    if (draggedPoint) {\n      // Handle point dragging\n      const normalizedPos = canvasToNormalized(mousePos.x, mousePos.y);\n      \n      if (draggedPoint.type === 'current') {\n        const newPolygon = [...currentPolygon];\n        newPolygon[draggedPoint.pointIndex] = normalizedPos;\n        setCurrentPolygon(newPolygon);\n        validatePolygon(newPolygon);\n      } else if (draggedPoint.type === 'selected' && selectedZone) {\n        const newPoints = [...selectedZone.polygon_points];\n        newPoints[draggedPoint.pointIndex] = normalizedPos;\n        \n        // Update the zone immediately for visual feedback\n        const updatedZone = {\n          ...selectedZone,\n          polygon_points: newPoints\n        };\n        \n        onZoneUpdated(selectedZone.zone_id, { polygon_points: newPoints });\n      }\n    } else {\n      // Handle hovering\n      const nearestPoint = findNearestPoint(mousePos.x, mousePos.y);\n      setHoveredPoint(nearestPoint);\n    }\n  }, [draggedPoint, currentPolygon, selectedZone, getMousePos, canvasToNormalized, findNearestPoint, validatePolygon, onZoneUpdated]);\n  \n  const handleMouseDown = useCallback((event) => {\n    const mousePos = getMousePos(event);\n    const nearestPoint = findNearestPoint(mousePos.x, mousePos.y, POINT_RADIUS);\n    \n    if (nearestPoint) {\n      // Start dragging a point\n      setDraggedPoint(nearestPoint);\n      event.preventDefault();\n    } else if (drawingMode === DRAWING_MODES.DRAW) {\n      // Add new point to current polygon\n      const normalizedPos = canvasToNormalized(mousePos.x, mousePos.y);\n      const newPolygon = [...currentPolygon, normalizedPos];\n      setCurrentPolygon(newPolygon);\n      validatePolygon(newPolygon);\n    } else if (drawingMode === DRAWING_MODES.SELECT) {\n      // Select zone at point\n      const zoneAtPoint = findZoneAtPoint(mousePos.x, mousePos.y);\n      if (zoneAtPoint) {\n        onZoneSelected(zoneAtPoint);\n      } else {\n        onZoneSelected(null);\n      }\n    }\n  }, [drawingMode, currentPolygon, getMousePos, findNearestPoint, canvasToNormalized, validatePolygon, findZoneAtPoint, onZoneSelected]);\n  \n  const handleMouseUp = useCallback(() => {\n    setDraggedPoint(null);\n  }, []);\n  \n  const handleDoubleClick = useCallback((event) => {\n    if (drawingMode === DRAWING_MODES.DRAW && currentPolygon.length >= MIN_POINTS) {\n      // Finish drawing\n      if (validatePolygon(currentPolygon)) {\n        const zoneId = rulesConfigurationAPI.generateUniqueId('zone');\n        const newZone = {\n          zone_id: zoneId,\n          name: `Zone ${zones.length + 1}`,\n          polygon_points: currentPolygon,\n          zone_type: selectedZoneType,\n          coordinate_system: 'normalized',\n          camera_id: currentCamera,\n          is_active: true,\n          confidence_threshold: 0.75,\n          description: `Auto-generated ${selectedZoneType} zone`\n        };\n        \n        onZoneCreated(newZone);\n        setCurrentPolygon([]);\n        onDrawingComplete();\n      }\n    }\n    \n    event.preventDefault();\n  }, [drawingMode, currentPolygon, validatePolygon, selectedZoneType, currentCamera, zones.length, onZoneCreated, onDrawingComplete]);\n  \n  const handleKeyDown = useCallback((event) => {\n    if (event.key === 'Escape') {\n      // Cancel current operation\n      setCurrentPolygon([]);\n      setDraggedPoint(null);\n      onDrawingComplete();\n    } else if (event.key === 'Delete' || event.key === 'Backspace') {\n      // Delete selected zone\n      if (selectedZone && drawingMode === DRAWING_MODES.SELECT) {\n        if (window.confirm(`Delete zone \"${selectedZone.name}\"?`)) {\n          onZoneUpdated(selectedZone.zone_id, null); // null indicates deletion\n        }\n      }\n    } else if (event.key === 'Enter') {\n      // Finish drawing\n      if (drawingMode === DRAWING_MODES.DRAW && currentPolygon.length >= MIN_POINTS) {\n        handleDoubleClick(event);\n      }\n    }\n  }, [selectedZone, drawingMode, currentPolygon, onDrawingComplete, onZoneUpdated, handleDoubleClick]);\n  \n  // ========================================\n  // EFFECTS FOR EVENT LISTENERS\n  // ========================================\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('mousedown', handleMouseDown);\n    canvas.addEventListener('mouseup', handleMouseUp);\n    canvas.addEventListener('dblclick', handleDoubleClick);\n    \n    // Keyboard events need to be on a focusable element\n    canvas.tabIndex = 0;\n    canvas.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      canvas.removeEventListener('mousedown', handleMouseDown);\n      canvas.removeEventListener('mouseup', handleMouseUp);\n      canvas.removeEventListener('dblclick', handleDoubleClick);\n      canvas.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleMouseMove, handleMouseDown, handleMouseUp, handleDoubleClick, handleKeyDown]);\n  \n  // ========================================\n  // PUBLIC METHODS (via ref)\n  // ========================================\n  \n  useImperativeHandle(ref, () => ({\n    clearCanvas: () => {\n      setCurrentPolygon([]);\n      setSelectedZone(null);\n      redrawCanvas();\n    },\n    \n    exportCanvasImage: () => {\n      const canvas = canvasRef.current;\n      if (canvas) {\n        return canvas.toDataURL('image/png');\n      }\n      return null;\n    },\n    \n    setDrawingMode: (mode) => {\n      setDrawingMode(mode);\n    },\n    \n    getCanvasSize: () => canvasSize\n  }));\n  \n  // ========================================\n  // RENDER\n  // ========================================\n  \n  return (\n    <CanvasContainer ref={containerRef} isDrawing={drawingMode === DRAWING_MODES.DRAW}>\n      <Canvas ref={canvasRef} />\n      \n      {/* Tools Overlay */}\n      <ToolsOverlay>\n        <ToolButton \n          active={drawingMode === DRAWING_MODES.SELECT}\n          onClick={() => setDrawingMode(DRAWING_MODES.SELECT)}\n        >\n          ğŸ–±ï¸ Select\n        </ToolButton>\n        \n        <ToolButton \n          active={drawingMode === DRAWING_MODES.DRAW}\n          onClick={() => setDrawingMode(DRAWING_MODES.DRAW)}\n        >\n          âœï¸ Draw\n        </ToolButton>\n        \n        {drawingMode === DRAWING_MODES.DRAW && (\n          <ZoneTypeSelector \n            value={selectedZoneType}\n            onChange={(e) => setSelectedZoneType(e.target.value)}\n          >\n            <option value=\"restricted\">ğŸš« Restricted</option>\n            <option value=\"monitored\">ğŸ‘ï¸ Monitored</option>\n            <option value=\"entry_exit\">ğŸšª Entry/Exit</option>\n            <option value=\"parking\">ğŸš— Parking</option>\n            <option value=\"perimeter\">ğŸ”’ Perimeter</option>\n            <option value=\"sensitive\">âš ï¸ Sensitive</option>\n            <option value=\"public\">ğŸŒ Public</option>\n            <option value=\"emergency\">ğŸš¨ Emergency</option>\n          </ZoneTypeSelector>\n        )}\n      </ToolsOverlay>\n      \n      {/* Info Panel */}\n      {(selectedZone || currentPolygon.length > 0) && (\n        <InfoPanel>\n          {selectedZone ? (\n            <div>\n              <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n                ğŸ“ {selectedZone.name}\n              </div>\n              <div>Type: {selectedZone.zone_type}</div>\n              <div>Points: {selectedZone.polygon_points.length}</div>\n              <div>Area: {(rulesConfigurationAPI.calculatePolygonArea(selectedZone.polygon_points) * 100).toFixed(2)}%</div>\n              <div style={{ fontSize: '0.8rem', marginTop: '8px', opacity: 0.8 }}>\n                Double-click to edit â€¢ Delete key to remove\n              </div>\n            </div>\n          ) : (\n            <div>\n              <div style={{ fontWeight: 'bold', marginBottom: '8px' }}>\n                âœï¸ Drawing Zone\n              </div>\n              <div>Points: {currentPolygon.length}</div>\n              <div>Type: {selectedZoneType}</div>\n              {!isPolygonValid && (\n                <div style={{ color: '#ff4444', fontSize: '0.8rem', marginTop: '4px' }}>\n                  âš ï¸ {validationMessage}\n                </div>\n              )}\n              <div style={{ fontSize: '0.8rem', marginTop: '8px', opacity: 0.8 }}>\n                Click to add points â€¢ Double-click or Enter to finish â€¢ Esc to cancel\n              </div>\n            </div>\n          )}\n        </InfoPanel>\n      )}\n      \n      {/* Status Bar */}\n      <StatusBar>\n        <div>\n          ğŸ¯ Camera: {currentCamera} â€¢ Zones: {zones.length} â€¢ Mode: {drawingMode}\n        </div>\n        <div>\n          Mouse: ({mousePosition.x.toFixed(0)}, {mousePosition.y.toFixed(0)})\n        </div>\n      </StatusBar>\n    </CanvasContainer>\n  );\n});\n\nZoneDrawingCanvas.displayName = 'ZoneDrawingCanvas';\n\nexport default ZoneDrawingCanvas;