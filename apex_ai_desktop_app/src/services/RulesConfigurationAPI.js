/**\n * APEX AI RULES CONFIGURATION API SERVICE\n * =======================================\n * Frontend service for managing geofencing zones and security rules\n * Handles REST API communication with backend and WebSocket integration\n * \n * Features:\n * - CRUD operations for zones and rules\n * - Real-time WebSocket updates\n * - Error handling and retry logic\n * - Data validation and formatting\n * - Configuration import/export\n * - Live rule testing\n */\n\nimport io from 'socket.io-client';\n\nclass RulesConfigurationAPI {\n  constructor() {\n    this.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';\n    this.rulesConfigURL = `${this.baseURL}/rules-config`;\n    this.socket = null;\n    this.eventListeners = new Map();\n    \n    // Initialize WebSocket connection\n    this.initializeWebSocket();\n  }\n\n  // ========================================\n  // WEBSOCKET MANAGEMENT\n  // ========================================\n\n  initializeWebSocket() {\n    try {\n      const socketURL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5000';\n      this.socket = io(socketURL, {\n        transports: ['websocket', 'polling'],\n        timeout: 20000,\n        reconnection: true,\n        reconnectionDelay: 1000,\n        reconnectionDelayMax: 5000,\n        maxReconnectionAttempts: 5\n      });\n\n      this.socket.on('connect', () => {\n        console.log('üîó Rules Configuration WebSocket connected');\n      });\n\n      this.socket.on('disconnect', () => {\n        console.log('üîå Rules Configuration WebSocket disconnected');\n      });\n\n      this.socket.on('connect_error', (error) => {\n        console.error('‚ùå WebSocket connection error:', error);\n      });\n\n      // Listen for rules configuration events\n      this.socket.on('zone-created', (data) => this.handleWebSocketEvent('zone-created', data));\n      this.socket.on('zone-updated', (data) => this.handleWebSocketEvent('zone-updated', data));\n      this.socket.on('zone-deleted', (data) => this.handleWebSocketEvent('zone-deleted', data));\n      this.socket.on('rule-created', (data) => this.handleWebSocketEvent('rule-created', data));\n      this.socket.on('rule-updated', (data) => this.handleWebSocketEvent('rule-updated', data));\n      this.socket.on('rule-deleted', (data) => this.handleWebSocketEvent('rule-deleted', data));\n      this.socket.on('configuration-imported', (data) => this.handleWebSocketEvent('configuration-imported', data));\n\n    } catch (error) {\n      console.error('‚ùå Failed to initialize WebSocket:', error);\n    }\n  }\n\n  handleWebSocketEvent(eventType, data) {\n    const listeners = this.eventListeners.get(eventType) || [];\n    listeners.forEach(callback => {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`‚ùå Error in ${eventType} event listener:`, error);\n      }\n    });\n  }\n\n  addEventListener(eventType, callback) {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, []);\n    }\n    this.eventListeners.get(eventType).push(callback);\n  }\n\n  removeEventListener(eventType, callback) {\n    const listeners = this.eventListeners.get(eventType) || [];\n    const index = listeners.indexOf(callback);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.eventListeners.clear();\n  }\n\n  // ========================================\n  // HTTP REQUEST HELPERS\n  // ========================================\n\n  async makeRequest(endpoint, options = {}) {\n    const defaultOptions = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      ...options\n    };\n\n    try {\n      const response = await fetch(`${this.rulesConfigURL}${endpoint}`, defaultOptions);\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({\n          error: `HTTP ${response.status}: ${response.statusText}`\n        }));\n        throw new Error(errorData.error || errorData.details || `Request failed with status ${response.status}`);\n      }\n\n      const data = await response.json();\n      return data;\n\n    } catch (error) {\n      console.error(`‚ùå API Request failed (${endpoint}):`, error);\n      throw error;\n    }\n  }\n\n  // ========================================\n  // GEOFENCING ZONES API\n  // ========================================\n\n  /**\n   * Get all geofencing zones with optional filtering\n   * @param {Object} filters - Optional filters (camera_id, monitor_id, zone_type)\n   * @returns {Promise<Object>} API response with zones array\n   */\n  async getZones(filters = {}) {\n    const queryParams = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        queryParams.append(key, value);\n      }\n    });\n\n    const queryString = queryParams.toString();\n    const endpoint = `/zones${queryString ? `?${queryString}` : ''}`;\n    \n    return await this.makeRequest(endpoint, { method: 'GET' });\n  }\n\n  /**\n   * Create a new geofencing zone\n   * @param {Object} zoneData - Zone configuration data\n   * @returns {Promise<Object>} API response with created zone\n   */\n  async createZone(zoneData) {\n    // Validate required fields\n    const requiredFields = ['zone_id', 'name', 'polygon_points', 'zone_type'];\n    for (const field of requiredFields) {\n      if (!zoneData[field]) {\n        throw new Error(`Missing required field: ${field}`);\n      }\n    }\n\n    // Validate polygon has at least 3 points\n    if (!Array.isArray(zoneData.polygon_points) || zoneData.polygon_points.length < 3) {\n      throw new Error('Polygon must have at least 3 points');\n    }\n\n    return await this.makeRequest('/zones', {\n      method: 'POST',\n      body: JSON.stringify(zoneData)\n    });\n  }\n\n  /**\n   * Update an existing geofencing zone\n   * @param {string} zoneId - Zone ID to update\n   * @param {Object} updateData - Fields to update\n   * @returns {Promise<Object>} API response with updated zone\n   */\n  async updateZone(zoneId, updateData) {\n    if (!zoneId) {\n      throw new Error('Zone ID is required');\n    }\n\n    return await this.makeRequest(`/zones/${encodeURIComponent(zoneId)}`, {\n      method: 'PUT',\n      body: JSON.stringify(updateData)\n    });\n  }\n\n  /**\n   * Delete a geofencing zone\n   * @param {string} zoneId - Zone ID to delete\n   * @returns {Promise<Object>} API response\n   */\n  async deleteZone(zoneId) {\n    if (!zoneId) {\n      throw new Error('Zone ID is required');\n    }\n\n    return await this.makeRequest(`/zones/${encodeURIComponent(zoneId)}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // ========================================\n  // SECURITY RULES API\n  // ========================================\n\n  /**\n   * Get all security rules with optional filtering\n   * @param {Object} filters - Optional filters (camera_id, zone_id, is_active, rule_type)\n   * @returns {Promise<Object>} API response with rules array\n   */\n  async getRules(filters = {}) {\n    const queryParams = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        queryParams.append(key, value);\n      }\n    });\n\n    const queryString = queryParams.toString();\n    const endpoint = `/rules${queryString ? `?${queryString}` : ''}`;\n    \n    return await this.makeRequest(endpoint, { method: 'GET' });\n  }\n\n  /**\n   * Create a new security rule\n   * @param {Object} ruleData - Rule configuration data\n   * @returns {Promise<Object>} API response with created rule\n   */\n  async createRule(ruleData) {\n    // Validate required fields\n    const requiredFields = ['rule_id', 'name', 'zone_ids', 'conditions', 'actions'];\n    for (const field of requiredFields) {\n      if (!ruleData[field]) {\n        throw new Error(`Missing required field: ${field}`);\n      }\n    }\n\n    // Validate arrays\n    const arrayFields = ['zone_ids', 'conditions', 'actions'];\n    for (const field of arrayFields) {\n      if (!Array.isArray(ruleData[field])) {\n        throw new Error(`${field} must be an array`);\n      }\n    }\n\n    return await this.makeRequest('/rules', {\n      method: 'POST',\n      body: JSON.stringify(ruleData)\n    });\n  }\n\n  /**\n   * Update an existing security rule\n   * @param {string} ruleId - Rule ID to update\n   * @param {Object} updateData - Fields to update\n   * @returns {Promise<Object>} API response with updated rule\n   */\n  async updateRule(ruleId, updateData) {\n    if (!ruleId) {\n      throw new Error('Rule ID is required');\n    }\n\n    return await this.makeRequest(`/rules/${encodeURIComponent(ruleId)}`, {\n      method: 'PUT',\n      body: JSON.stringify(updateData)\n    });\n  }\n\n  /**\n   * Delete a security rule\n   * @param {string} ruleId - Rule ID to delete\n   * @returns {Promise<Object>} API response\n   */\n  async deleteRule(ruleId) {\n    if (!ruleId) {\n      throw new Error('Rule ID is required');\n    }\n\n    return await this.makeRequest(`/rules/${encodeURIComponent(ruleId)}`, {\n      method: 'DELETE'\n    });\n  }\n\n  // ========================================\n  // CONFIGURATION MANAGEMENT\n  // ========================================\n\n  /**\n   * Test a security rule against sample threat data\n   * @param {Object} rule - Rule to test\n   * @param {Object} threatData - Sample threat data\n   * @returns {Promise<Object>} Test results\n   */\n  async testRule(rule, threatData) {\n    if (!rule || !threatData) {\n      throw new Error('Both rule and threat data are required');\n    }\n\n    return await this.makeRequest('/test-rule', {\n      method: 'POST',\n      body: JSON.stringify({ rule, threat_data: threatData })\n    });\n  }\n\n  /**\n   * Export configuration to JSON\n   * @param {Object} options - Export options (include_zones, include_rules, camera_id)\n   * @returns {Promise<Object>} Export data\n   */\n  async exportConfiguration(options = {}) {\n    return await this.makeRequest('/export', {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n\n  /**\n   * Import configuration from JSON\n   * @param {Object} importData - Configuration data to import\n   * @param {string} mergeMode - 'replace' or 'merge'\n   * @returns {Promise<Object>} Import results\n   */\n  async importConfiguration(importData, mergeMode = 'replace') {\n    if (!importData) {\n      throw new Error('Import data is required');\n    }\n\n    return await this.makeRequest('/import', {\n      method: 'POST',\n      body: JSON.stringify({ import_data: importData, merge_mode: mergeMode })\n    });\n  }\n\n  /**\n   * Get system status and statistics\n   * @returns {Promise<Object>} System status data\n   */\n  async getSystemStatus() {\n    return await this.makeRequest('/status', { method: 'GET' });\n  }\n\n  // ========================================\n  // UTILITY METHODS\n  // ========================================\n\n  /**\n   * Validate zone data before sending to API\n   * @param {Object} zoneData - Zone data to validate\n   * @returns {Object} Validation result with isValid and errors\n   */\n  validateZoneData(zoneData) {\n    const errors = [];\n    \n    // Required fields\n    const requiredFields = {\n      zone_id: 'Zone ID',\n      name: 'Zone Name',\n      polygon_points: 'Polygon Points',\n      zone_type: 'Zone Type'\n    };\n\n    Object.entries(requiredFields).forEach(([field, label]) => {\n      if (!zoneData[field]) {\n        errors.push(`${label} is required`);\n      }\n    });\n\n    // Validate polygon points\n    if (zoneData.polygon_points) {\n      if (!Array.isArray(zoneData.polygon_points)) {\n        errors.push('Polygon points must be an array');\n      } else if (zoneData.polygon_points.length < 3) {\n        errors.push('Polygon must have at least 3 points');\n      } else {\n        // Validate each point\n        zoneData.polygon_points.forEach((point, index) => {\n          if (!Array.isArray(point) || point.length !== 2) {\n            errors.push(`Point ${index + 1} must be an array of [x, y] coordinates`);\n          } else if (typeof point[0] !== 'number' || typeof point[1] !== 'number') {\n            errors.push(`Point ${index + 1} coordinates must be numbers`);\n          }\n        });\n      }\n    }\n\n    // Validate zone type\n    const validZoneTypes = ['restricted', 'monitored', 'entry_exit', 'parking', 'perimeter', 'sensitive', 'public', 'emergency'];\n    if (zoneData.zone_type && !validZoneTypes.includes(zoneData.zone_type)) {\n      errors.push(`Zone type must be one of: ${validZoneTypes.join(', ')}`);\n    }\n\n    // Validate confidence threshold\n    if (zoneData.confidence_threshold !== undefined) {\n      const threshold = parseFloat(zoneData.confidence_threshold);\n      if (isNaN(threshold) || threshold < 0 || threshold > 1) {\n        errors.push('Confidence threshold must be a number between 0 and 1');\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Validate rule data before sending to API\n   * @param {Object} ruleData - Rule data to validate\n   * @returns {Object} Validation result with isValid and errors\n   */\n  validateRuleData(ruleData) {\n    const errors = [];\n    \n    // Required fields\n    const requiredFields = {\n      rule_id: 'Rule ID',\n      name: 'Rule Name',\n      zone_ids: 'Zone IDs',\n      conditions: 'Conditions',\n      actions: 'Actions'\n    };\n\n    Object.entries(requiredFields).forEach(([field, label]) => {\n      if (!ruleData[field]) {\n        errors.push(`${label} is required`);\n      }\n    });\n\n    // Validate arrays\n    const arrayFields = ['zone_ids', 'conditions', 'actions'];\n    arrayFields.forEach(field => {\n      if (ruleData[field] && !Array.isArray(ruleData[field])) {\n        errors.push(`${field.replace('_', ' ')} must be an array`);\n      } else if (ruleData[field] && ruleData[field].length === 0) {\n        errors.push(`${field.replace('_', ' ')} cannot be empty`);\n      }\n    });\n\n    // Validate priority\n    if (ruleData.priority !== undefined) {\n      const priority = parseInt(ruleData.priority);\n      if (isNaN(priority) || priority < 1 || priority > 10) {\n        errors.push('Priority must be a number between 1 and 10');\n      }\n    }\n\n    // Validate confidence threshold\n    if (ruleData.confidence_threshold !== undefined) {\n      const threshold = parseFloat(ruleData.confidence_threshold);\n      if (isNaN(threshold) || threshold < 0 || threshold > 1) {\n        errors.push('Confidence threshold must be a number between 0 and 1');\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Generate a unique ID for zones or rules\n   * @param {string} prefix - Prefix for the ID (e.g., 'zone', 'rule')\n   * @returns {string} Unique ID\n   */\n  generateUniqueId(prefix = 'item') {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substr(2, 9);\n    return `${prefix}_${timestamp}_${random}`;\n  }\n\n  /**\n   * Format polygon points for display\n   * @param {Array} points - Array of [x, y] coordinate pairs\n   * @returns {string} Formatted string representation\n   */\n  formatPolygonPoints(points) {\n    if (!Array.isArray(points)) return 'Invalid points';\n    return points.map(point => `(${point[0].toFixed(3)}, ${point[1].toFixed(3)})`).join(' ‚Üí ');\n  }\n\n  /**\n   * Calculate polygon area (for normalized coordinates)\n   * @param {Array} points - Array of [x, y] coordinate pairs\n   * @returns {number} Area of the polygon\n   */\n  calculatePolygonArea(points) {\n    if (!Array.isArray(points) || points.length < 3) return 0;\n    \n    let area = 0;\n    const n = points.length;\n    \n    for (let i = 0; i < n; i++) {\n      const j = (i + 1) % n;\n      area += points[i][0] * points[j][1];\n      area -= points[j][0] * points[i][1];\n    }\n    \n    return Math.abs(area) / 2;\n  }\n}\n\n// Create and export singleton instance\nconst rulesConfigurationAPI = new RulesConfigurationAPI();\nexport default rulesConfigurationAPI;\n\n// Also export the class for testing or multiple instances\nexport { RulesConfigurationAPI };