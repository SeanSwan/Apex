// client-portal/src/services/clientAPI.ts\n/**\n * Client Portal API Service\n * =========================\n * Handles all API communications for the Aegis Client Portal\n * including dashboard data, incidents, evidence, and analytics\n */\n\nimport axios, { AxiosResponse, AxiosRequestConfig } from 'axios';\nimport toast from 'react-hot-toast';\nimport {\n  ApiResponse,\n  PaginatedResponse,\n  DashboardOverview,\n  IncidentTypeBreakdown,\n  ResponseTimeStats,\n  PropertyHotspot,\n  LocationHotspot,\n  Property,\n  Incident,\n  IncidentDetails,\n  IncidentFilters,\n  FilterOption,\n  EvidenceFile,\n  EvidenceFilters,\n  EvidenceStats,\n  DateRange\n} from '@/types/client.types';\nimport { AuthService } from './authService';\n\n// ===========================\n// CONFIGURATION & CONSTANTS\n// ===========================\n\nconst API_BASE_URL = import.meta.env.VITE_API_URL || '/api';\nconst CLIENT_API_BASE = `${API_BASE_URL}/client/v1`;\n\n// Request timeout configuration\nconst DEFAULT_TIMEOUT = 30000; // 30 seconds\nconst LONG_REQUEST_TIMEOUT = 60000; // 60 seconds for exports/downloads\n\n// ===========================\n// AXIOS INSTANCE CONFIGURATION\n// ===========================\n\n// Create axios instance for API requests\nconst apiClient = axios.create({\n  baseURL: CLIENT_API_BASE,\n  timeout: DEFAULT_TIMEOUT,\n  withCredentials: true,\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Client-Portal': 'aegis-v1.0'\n  }\n});\n\n// Request interceptor to add auth token and handle request logging\napiClient.interceptors.request.use(\n  (config) => {\n    // Add authentication token\n    const token = localStorage.getItem('aegis_access_token');\n    if (token && config.headers) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Add request timestamp for debugging\n    config.metadata = { startTime: Date.now() };\n    \n    // Log API requests in development\n    if (import.meta.env.DEV) {\n      console.log(`[CLIENT-API] ${config.method?.toUpperCase()} ${config.url}`, config.params || config.data);\n    }\n    \n    return config;\n  },\n  (error) => {\n    console.error('[CLIENT-API] Request error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor to handle responses and errors\napiClient.interceptors.response.use(\n  (response) => {\n    // Log response time in development\n    if (import.meta.env.DEV && response.config.metadata) {\n      const duration = Date.now() - response.config.metadata.startTime;\n      console.log(`[CLIENT-API] Response ${response.status} in ${duration}ms:`, response.config.url);\n    }\n    \n    return response;\n  },\n  async (error) => {\n    const { response, config } = error;\n    \n    // Log error details\n    console.error('[CLIENT-API] Response error:', {\n      status: response?.status,\n      url: config?.url,\n      message: response?.data?.message || error.message\n    });\n    \n    // Handle authentication errors\n    if (response?.status === 401) {\n      toast.error('Session expired. Please log in again.');\n      await AuthService.logout();\n      return Promise.reject(error);\n    }\n    \n    // Handle rate limiting\n    if (response?.status === 429) {\n      const retryAfter = response.headers['retry-after'] || 60;\n      toast.error(`Too many requests. Please wait ${retryAfter} seconds.`);\n    }\n    \n    // Handle server errors\n    if (response?.status >= 500) {\n      toast.error('Server error. Please try again later.');\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// ===========================\n// API REQUEST HELPERS\n// ===========================\n\n/**\n * Make GET request with proper error handling\n */\nconst apiGet = async <T>(\n  endpoint: string, \n  params?: Record<string, any>,\n  config?: AxiosRequestConfig\n): Promise<T> => {\n  try {\n    const response: AxiosResponse<T> = await apiClient.get(endpoint, {\n      params,\n      ...config\n    });\n    return response.data;\n  } catch (error: any) {\n    throw new Error(error.response?.data?.message || error.message || 'Request failed');\n  }\n};\n\n/**\n * Make POST request with proper error handling\n */\nconst apiPost = async <T>(\n  endpoint: string, \n  data?: any,\n  config?: AxiosRequestConfig\n): Promise<T> => {\n  try {\n    const response: AxiosResponse<T> = await apiClient.post(endpoint, data, config);\n    return response.data;\n  } catch (error: any) {\n    throw new Error(error.response?.data?.message || error.message || 'Request failed');\n  }\n};\n\n/**\n * Download file with progress tracking\n */\nconst downloadFile = async (\n  endpoint: string,\n  filename: string,\n  onProgress?: (progress: number) => void\n): Promise<void> => {\n  try {\n    const response = await apiClient.get(endpoint, {\n      responseType: 'blob',\n      timeout: LONG_REQUEST_TIMEOUT,\n      onDownloadProgress: (progressEvent) => {\n        if (onProgress && progressEvent.total) {\n          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n          onProgress(progress);\n        }\n      }\n    });\n    \n    // Create download link\n    const url = window.URL.createObjectURL(new Blob([response.data]));\n    const link = document.createElement('a');\n    link.href = url;\n    link.setAttribute('download', filename);\n    document.body.appendChild(link);\n    link.click();\n    \n    // Cleanup\n    document.body.removeChild(link);\n    window.URL.revokeObjectURL(url);\n    \n  } catch (error: any) {\n    throw new Error(error.response?.data?.message || error.message || 'Download failed');\n  }\n};\n\n// ===========================\n// DASHBOARD API METHODS\n// ===========================\n\nexport class DashboardAPI {\n  /**\n   * Get dashboard overview with KPIs and trends\n   */\n  static async getOverview(dateRange: DateRange = '30'): Promise<DashboardOverview> {\n    return apiGet<ApiResponse<DashboardOverview>>('/dashboard/overview', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Invalid dashboard data received');\n        }\n        return response.data;\n      });\n  }\n  \n  /**\n   * Get incident type breakdown\n   */\n  static async getIncidentTypes(dateRange: DateRange = '30'): Promise<IncidentTypeBreakdown[]> {\n    return apiGet<ApiResponse<{ incidentTypes: IncidentTypeBreakdown[] }>>('/dashboard/incident-types', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Invalid incident types data received');\n        }\n        return response.data.incidentTypes;\n      });\n  }\n  \n  /**\n   * Get response time analytics\n   */\n  static async getResponseTimes(dateRange: DateRange = '30'): Promise<{\n    overall: ResponseTimeStats;\n    byIncidentType: Array<{ incidentType: string; count: number; avgResponseMinutes: number }>;\n    trends: Array<{ date: string; resolvedCount: number; avgResponseMinutes: number }>;\n  }> {\n    return apiGet('/dashboard/response-times', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Invalid response times data received');\n        }\n        return response.data;\n      });\n  }\n  \n  /**\n   * Get security hotspots\n   */\n  static async getHotspots(dateRange: DateRange = '30'): Promise<{\n    propertyHotspots: PropertyHotspot[];\n    locationHotspots: LocationHotspot[];\n  }> {\n    return apiGet('/dashboard/hotspots', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Invalid hotspots data received');\n        }\n        return response.data;\n      });\n  }\n  \n  /**\n   * Get properties with statistics\n   */\n  static async getProperties(dateRange: DateRange = '30'): Promise<Property[]> {\n    return apiGet<ApiResponse<{ properties: Property[] }>>('/dashboard/properties', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Invalid properties data received');\n        }\n        return response.data.properties;\n      });\n  }\n}\n\n// ===========================\n// INCIDENTS API METHODS\n// ===========================\n\nexport class IncidentsAPI {\n  /**\n   * Get paginated incidents list\n   */\n  static async getIncidents({\n    page = 1,\n    limit = 25,\n    sortBy = 'incidentDate',\n    sortOrder = 'desc',\n    ...filters\n  }: {\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  } & IncidentFilters): Promise<PaginatedResponse<Incident>> {\n    const params = {\n      page,\n      limit,\n      sortBy,\n      sortOrder,\n      ...filters\n    };\n    \n    return apiGet<PaginatedResponse<Incident>>('/incidents', params);\n  }\n  \n  /**\n   * Get incident details by ID\n   */\n  static async getIncidentDetails(incidentId: number): Promise<IncidentDetails> {\n    return apiGet<ApiResponse<{ incident: IncidentDetails; evidence: any[]; callLogs: any[] }>>(`/incidents/${incidentId}`)\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Incident not found');\n        }\n        \n        // Merge incident with related data\n        return {\n          ...response.data.incident,\n          evidence: response.data.evidence,\n          callLogs: response.data.callLogs\n        };\n      });\n  }\n  \n  /**\n   * Get filter options for incidents\n   */\n  static async getFilterOptions(): Promise<{\n    incidentTypes: FilterOption[];\n    severities: FilterOption[];\n    statuses: FilterOption[];\n    properties: FilterOption[];\n  }> {\n    return apiGet<ApiResponse<{\n      incidentTypes: FilterOption[];\n      severities: FilterOption[];\n      statuses: FilterOption[];\n      properties: FilterOption[];\n    }>>('/incidents/filters/options')\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Failed to load filter options');\n        }\n        return response.data;\n      });\n  }\n  \n  /**\n   * Export incidents data\n   */\n  static async exportIncidents(\n    filters: IncidentFilters,\n    format: 'csv' | 'json' = 'csv',\n    onProgress?: (progress: number) => void\n  ): Promise<void> {\n    const params = new URLSearchParams({\n      ...filters,\n      format\n    } as any);\n    \n    const filename = `incidents_export_${new Date().toISOString().split('T')[0]}.${format}`;\n    \n    return downloadFile(`/incidents/export?${params}`, filename, onProgress);\n  }\n}\n\n// ===========================\n// EVIDENCE API METHODS\n// ===========================\n\nexport class EvidenceAPI {\n  /**\n   * Get paginated evidence files list\n   */\n  static async getEvidenceFiles({\n    page = 1,\n    limit = 20,\n    sortBy = 'createdAt',\n    sortOrder = 'desc',\n    ...filters\n  }: {\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  } & EvidenceFilters): Promise<PaginatedResponse<EvidenceFile>> {\n    const params = {\n      page,\n      limit,\n      sortBy,\n      sortOrder,\n      ...filters\n    };\n    \n    return apiGet<PaginatedResponse<EvidenceFile>>('/evidence', params);\n  }\n  \n  /**\n   * Get evidence file details by ID\n   */\n  static async getEvidenceDetails(evidenceId: number): Promise<EvidenceFile> {\n    return apiGet<ApiResponse<{ evidence: EvidenceFile }>>(`/evidence/${evidenceId}`)\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Evidence file not found');\n        }\n        return response.data.evidence;\n      });\n  }\n  \n  /**\n   * Get evidence file thumbnail URL\n   */\n  static getThumbnailUrl(evidenceId: number): string {\n    return `${CLIENT_API_BASE}/evidence/${evidenceId}/thumbnail`;\n  }\n  \n  /**\n   * Download evidence file\n   */\n  static async downloadEvidenceFile(\n    evidenceId: number,\n    filename: string,\n    onProgress?: (progress: number) => void\n  ): Promise<void> {\n    return downloadFile(`/evidence/${evidenceId}/download`, filename, onProgress);\n  }\n  \n  /**\n   * Get filter options for evidence\n   */\n  static async getFilterOptions(): Promise<{\n    fileTypes: FilterOption[];\n    incidents: FilterOption[];\n  }> {\n    return apiGet<ApiResponse<{\n      fileTypes: FilterOption[];\n      incidents: FilterOption[];\n    }>>('/evidence/filters/options')\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Failed to load evidence filter options');\n        }\n        return response.data;\n      });\n  }\n  \n  /**\n   * Get evidence statistics\n   */\n  static async getEvidenceStats(dateRange: DateRange = '30'): Promise<EvidenceStats> {\n    return apiGet<ApiResponse<{ stats: EvidenceStats }>>('/evidence/stats', { dateRange })\n      .then(response => {\n        if (!response.success || !response.data) {\n          throw new Error('Failed to load evidence statistics');\n        }\n        return response.data.stats;\n      });\n  }\n}\n\n// ===========================\n// UTILITY FUNCTIONS\n// ===========================\n\n/**\n * Format file size in human readable format\n */\nexport const formatFileSize = (bytes: number): string => {\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let size = bytes;\n  let unitIndex = 0;\n  \n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n  \n  return `${Math.round(size * 10) / 10} ${units[unitIndex]}`;\n};\n\n/**\n * Format incident type for display\n */\nexport const formatIncidentType = (type: string): string => {\n  return type\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, l => l.toUpperCase());\n};\n\n/**\n * Get severity color class\n */\nexport const getSeverityColor = (severity: string): string => {\n  const colors = {\n    low: 'text-green-600 bg-green-50',\n    medium: 'text-yellow-600 bg-yellow-50',\n    high: 'text-orange-600 bg-orange-50',\n    critical: 'text-red-600 bg-red-50'\n  };\n  return colors[severity as keyof typeof colors] || 'text-gray-600 bg-gray-50';\n};\n\n/**\n * Get status color class\n */\nexport const getStatusColor = (status: string): string => {\n  const colors = {\n    reported: 'text-blue-600 bg-blue-50',\n    investigating: 'text-yellow-600 bg-yellow-50',\n    resolved: 'text-green-600 bg-green-50',\n    closed: 'text-gray-600 bg-gray-50'\n  };\n  return colors[status as keyof typeof colors] || 'text-gray-600 bg-gray-50';\n};\n\n/**\n * Check if incident is recent (within 24 hours)\n */\nexport const isRecentIncident = (incidentDate: string): boolean => {\n  const incident = new Date(incidentDate);\n  const now = new Date();\n  const twentyFourHours = 24 * 60 * 60 * 1000;\n  \n  return (now.getTime() - incident.getTime()) < twentyFourHours;\n};\n\n/**\n * Calculate confidence badge color\n */\nexport const getConfidenceBadgeColor = (confidence: number): string => {\n  if (confidence >= 95) return 'text-green-700 bg-green-100';\n  if (confidence >= 85) return 'text-blue-700 bg-blue-100';\n  if (confidence >= 70) return 'text-yellow-700 bg-yellow-100';\n  return 'text-red-700 bg-red-100';\n};\n\n// ===========================\n// EXPORT ALL APIs\n// ===========================\n\nexport const ClientAPI = {\n  Dashboard: DashboardAPI,\n  Incidents: IncidentsAPI,\n  Evidence: EvidenceAPI\n};\n\nexport default ClientAPI;"