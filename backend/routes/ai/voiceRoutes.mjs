/**\n * VOICE AI DISPATCHER ROUTES - MASTER PROMPT v49.0\n * ==================================================\n * Revolutionary Voice AI Dispatcher API endpoints\n * \n * Features:\n * - Twilio webhook handling for inbound calls\n * - Real-time call management and monitoring\n * - Voice-generated incident creation\n * - Human takeover capabilities\n * - Call transcription and recording management\n * - Standard Operating Procedures (SOP) management\n * - Emergency services dispatch integration\n */\n\nimport express from 'express';\nimport { getIO, emitSocketEvent } from '../../src/socket.js';\nimport pkg from 'pg';\nconst { Pool } = pkg;\nimport dotenv from 'dotenv';\nimport twilio from 'twilio';\nimport { v4 as uuidv4 } from 'uuid';\n\ndotenv.config();\nconst router = express.Router();\n\n// PostgreSQL connection pool\nconst pool = new Pool({\n  user: process.env.PG_USER,\n  host: process.env.PG_HOST,\n  database: process.env.PG_DB,\n  password: process.env.PG_PASSWORD,\n  port: Number(process.env.PG_PORT),\n});\n\n// Twilio configuration\nconst accountSid = process.env.TWILIO_ACCOUNT_SID;\nconst authToken = process.env.TWILIO_AUTH_TOKEN;\nconst twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER;\nconst twilioClient = twilio(accountSid, authToken);\n\n// Middleware to parse Twilio webhooks\nrouter.use(express.urlencoded({ extended: false }));\n\n/**\n * TWILIO WEBHOOK HANDLERS\n * =======================\n * Handle inbound calls and call status updates\n */\n\n/**\n * POST /api/voice/webhook/incoming\n * Twilio webhook for incoming calls\n */\nrouter.post('/webhook/incoming', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      From: callerPhone,\n      To: twilioNumber,\n      CallStatus,\n      Direction\n    } = req.body;\n\n    console.log(`📞 Incoming call: ${CallSid} from ${callerPhone}`);\n\n    // Create TwiML response to answer and start processing\n    const twiml = new twilio.twiml.VoiceResponse();\n    \n    // Initial greeting\n    twiml.say({\n      voice: 'Polly.Joanna',\n      language: 'en-US'\n    }, 'Hello, this is APEX AI Security Dispatch. Please hold while I connect you.');\n    \n    // Start call recording\n    twiml.record({\n      action: '/api/voice/webhook/recording',\n      method: 'POST',\n      transcribe: true,\n      transcribeCallback: '/api/voice/webhook/transcription',\n      maxLength: 600, // 10 minutes max\n      playBeep: false\n    });\n    \n    // Gather speech input\n    const gather = twiml.gather({\n      input: 'speech',\n      action: '/api/voice/webhook/speech',\n      method: 'POST',\n      speechTimeout: 'auto',\n      enhanced: true\n    });\n    \n    gather.say({\n      voice: 'Polly.Joanna'\n    }, 'Please describe the nature of your security concern or emergency.');\n    \n    // Fallback if no speech detected\n    twiml.say('I didn\\'t hear a response. Please try again.');\n    twiml.redirect('/api/voice/webhook/speech');\n\n    // Create call log in database\n    const callId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    try {\n      await pool.query(`\n        INSERT INTO call_logs (\n          call_id, twilio_call_sid, caller_phone, call_type, status,\n          started_at, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7)\n      `, [\n        callId,\n        CallSid,\n        callerPhone,\n        'general_inquiry',\n        'answered',\n        new Date(),\n        new Date()\n      ]);\n      \n      console.log(`📋 Call log created: ${callId}`);\n    } catch (dbError) {\n      console.error('❌ Database call log error:', dbError);\n    }\n\n    // Notify Voice AI Agent via WebSocket\n    emitSocketEvent('voice_call_incoming', {\n      call_id: callId,\n      twilio_call_sid: CallSid,\n      caller_phone: callerPhone,\n      status: 'answered',\n      timestamp: new Date().toISOString()\n    });\n\n    // Send TwiML response\n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Incoming call webhook error:', error);\n    \n    // Error fallback TwiML\n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('I\\'m sorry, there\\'s a technical issue. Please call back in a moment.');\n    errorTwiml.hangup();\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * POST /api/voice/webhook/speech\n * Handle speech input from caller\n */\nrouter.post('/webhook/speech', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      SpeechResult,\n      Confidence,\n      From: callerPhone\n    } = req.body;\n\n    console.log(`🎤 Speech received: ${SpeechResult} (${Confidence}% confidence)`);\n\n    // Get call from database\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE twilio_call_sid = $1',\n      [CallSid]\n    );\n    \n    if (callQuery.rows.length === 0) {\n      throw new Error(`Call not found: ${CallSid}`);\n    }\n    \n    const call = callQuery.rows[0];\n\n    // Update transcript in database\n    const currentTranscript = call.transcript || [];\n    currentTranscript.push({\n      timestamp: new Date().toISOString(),\n      speaker: 'caller',\n      message: SpeechResult,\n      confidence: parseFloat(Confidence) / 100\n    });\n\n    await pool.query(\n      'UPDATE call_logs SET transcript = $1, updated_at = $2 WHERE call_id = $3',\n      [JSON.stringify(currentTranscript), new Date(), call.call_id]\n    );\n\n    // Notify Voice AI Agent for processing\n    emitSocketEvent('voice_speech_received', {\n      call_id: call.call_id,\n      twilio_call_sid: CallSid,\n      transcript: SpeechResult,\n      confidence: parseFloat(Confidence) / 100,\n      timestamp: new Date().toISOString()\n    });\n\n    // Generate AI response (this would integrate with Voice AI Agent)\n    const aiResponse = await generateAIResponse(call, SpeechResult);\n\n    // Create TwiML response\n    const twiml = new twilio.twiml.VoiceResponse();\n    \n    twiml.say({\n      voice: 'Polly.Joanna'\n    }, aiResponse);\n    \n    // Continue gathering speech\n    const gather = twiml.gather({\n      input: 'speech',\n      action: '/api/voice/webhook/speech',\n      method: 'POST',\n      speechTimeout: 'auto',\n      enhanced: true\n    });\n    \n    gather.say('Please continue or provide additional details.');\n    \n    // Check if we should end the call or create incident\n    if (shouldCreateIncident(currentTranscript)) {\n      twiml.redirect('/api/voice/webhook/complete');\n    }\n\n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Speech webhook error:', error);\n    \n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('I\\'m processing your request. Please hold on.');\n    errorTwiml.redirect('/api/voice/webhook/speech');\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * POST /api/voice/webhook/recording\n * Handle call recording completion\n */\nrouter.post('/webhook/recording', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      RecordingUrl,\n      RecordingDuration\n    } = req.body;\n\n    console.log(`🎙️ Recording completed: ${RecordingUrl} (${RecordingDuration}s)`);\n\n    // Update call log with recording URL\n    await pool.query(\n      'UPDATE call_logs SET call_recording_url = $1, duration_seconds = $2 WHERE twilio_call_sid = $3',\n      [RecordingUrl, parseInt(RecordingDuration), CallSid]\n    );\n\n    // Notify system of recording completion\n    emitSocketEvent('voice_recording_complete', {\n      twilio_call_sid: CallSid,\n      recording_url: RecordingUrl,\n      duration_seconds: parseInt(RecordingDuration),\n      timestamp: new Date().toISOString()\n    });\n\n    res.sendStatus(200);\n    \n  } catch (error) {\n    console.error('❌ Recording webhook error:', error);\n    res.sendStatus(500);\n  }\n});\n\n/**\n * POST /api/voice/webhook/transcription\n * Handle call transcription completion\n */\nrouter.post('/webhook/transcription', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      TranscriptionText,\n      TranscriptionStatus\n    } = req.body;\n\n    if (TranscriptionStatus === 'completed') {\n      console.log(`📝 Transcription completed for ${CallSid}`);\n      \n      // Update call log with full transcription\n      await pool.query(\n        'UPDATE call_logs SET metadata = metadata || $1 WHERE twilio_call_sid = $2',\n        [JSON.stringify({ full_transcription: TranscriptionText }), CallSid]\n      );\n    }\n\n    res.sendStatus(200);\n    \n  } catch (error) {\n    console.error('❌ Transcription webhook error:', error);\n    res.sendStatus(500);\n  }\n});\n\n/**\n * POST /api/voice/webhook/complete\n * Complete the call and create incident\n */\nrouter.post('/webhook/complete', async (req, res) => {\n  try {\n    const { CallSid } = req.body;\n\n    // Get call from database\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE twilio_call_sid = $1',\n      [CallSid]\n    );\n    \n    if (callQuery.rows.length > 0) {\n      const call = callQuery.rows[0];\n      \n      // Create incident from call\n      const incidentId = await createIncidentFromCall(call);\n      \n      if (incidentId) {\n        // Update call log\n        await pool.query(\n          'UPDATE call_logs SET incident_created = TRUE, incident_id = $1, status = $2 WHERE call_id = $3',\n          [incidentId, 'completed', call.call_id]\n        );\n        \n        // Final message to caller\n        const twiml = new twilio.twiml.VoiceResponse();\n        twiml.say({\n          voice: 'Polly.Joanna'\n        }, `Thank you for your report. I've created incident number ${incidentId.slice(-8)} and dispatched the appropriate response. You will receive a follow-up call if needed. Have a safe day.`);\n        twiml.hangup();\n        \n        res.type('text/xml');\n        res.send(twiml.toString());\n        \n        return;\n      }\n    }\n    \n    // Fallback completion\n    const twiml = new twilio.twiml.VoiceResponse();\n    twiml.say('Thank you for calling APEX AI Security. Your report has been received and appropriate action will be taken.');\n    twiml.hangup();\n    \n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Call completion error:', error);\n    \n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('Thank you for calling. Your report has been received.');\n    errorTwiml.hangup();\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * CALL MANAGEMENT API ENDPOINTS\n * ==============================\n * Manage active calls and human intervention\n */\n\n/**\n * GET /api/voice/calls/active\n * Get all active voice calls\n */\nrouter.get('/calls/active', async (req, res) => {\n  try {\n    const query = `\n      SELECT \n        cl.*,\n        i.incident_number,\n        i.priority,\n        i.status as incident_status\n      FROM call_logs cl\n      LEFT JOIN incidents i ON i.id = cl.incident_id\n      WHERE cl.status IN ('answered', 'in_progress', 'gathering_info')\n      ORDER BY cl.started_at DESC\n    `;\n    \n    const result = await pool.query(query);\n    \n    res.json({\n      success: true,\n      active_calls: result.rows,\n      total_active: result.rows.length\n    });\n    \n  } catch (error) {\n    console.error('❌ Get active calls error:', error);\n    res.status(500).json({\n      error: 'Failed to get active calls',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/voice/calls/{call_id}\n * Get specific call details\n */\nrouter.get('/calls/:call_id', async (req, res) => {\n  const { call_id } = req.params;\n  \n  try {\n    const query = `\n      SELECT \n        cl.*,\n        i.incident_number,\n        i.title as incident_title,\n        i.priority,\n        i.status as incident_status\n      FROM call_logs cl\n      LEFT JOIN incidents i ON i.id = cl.incident_id\n      WHERE cl.call_id = $1\n    `;\n    \n    const result = await pool.query(query, [call_id]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Call not found' });\n    }\n    \n    res.json({\n      success: true,\n      call: result.rows[0]\n    });\n    \n  } catch (error) {\n    console.error('❌ Get call details error:', error);\n    res.status(500).json({\n      error: 'Failed to get call details',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/voice/calls/{call_id}/takeover\n * Human dispatcher takes over the call\n */\nrouter.post('/calls/:call_id/takeover', async (req, res) => {\n  const { call_id } = req.params;\n  const { dispatcher_id, reason } = req.body;\n  \n  try {\n    // Update call log\n    await pool.query(\n      `UPDATE call_logs SET \n        human_takeover = TRUE,\n        takeover_time = $1,\n        metadata = metadata || $2\n       WHERE call_id = $3`,\n      [\n        new Date(),\n        JSON.stringify({\n          takeover_dispatcher: dispatcher_id,\n          takeover_reason: reason || 'Manual intervention'\n        }),\n        call_id\n      ]\n    );\n    \n    // Get call details for Twilio transfer\n    const callQuery = await pool.query(\n      'SELECT twilio_call_sid FROM call_logs WHERE call_id = $1',\n      [call_id]\n    );\n    \n    if (callQuery.rows.length > 0) {\n      const { twilio_call_sid } = callQuery.rows[0];\n      \n      // Notify via WebSocket for real-time UI updates\n      emitSocketEvent('voice_call_takeover', {\n        call_id,\n        twilio_call_sid,\n        dispatcher_id,\n        reason,\n        timestamp: new Date().toISOString()\n      });\n      \n      // In production, you would redirect the Twilio call to human dispatcher\n      // For now, we'll just mark it as taken over\n      \n      res.json({\n        success: true,\n        message: 'Call takeover initiated',\n        call_id,\n        twilio_call_sid\n      });\n    } else {\n      res.status(404).json({ error: 'Call not found' });\n    }\n    \n  } catch (error) {\n    console.error('❌ Call takeover error:', error);\n    res.status(500).json({\n      error: 'Failed to takeover call',\n      details: error.message\n    });\n  }\n});\n\n/**\n * INCIDENT CREATION FROM VOICE CALLS\n * ===================================\n * Create structured incidents from voice calls\n */\n\n/**\n * POST /api/voice/incidents/create\n * Create incident from voice call\n */\nrouter.post('/incidents/create', async (req, res) => {\n  try {\n    const {\n      call_id,\n      incident_type,\n      priority,\n      description,\n      location,\n      caller_name\n    } = req.body;\n    \n    // Get call details\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE call_id = $1',\n      [call_id]\n    );\n    \n    if (callQuery.rows.length === 0) {\n      return res.status(404).json({ error: 'Call not found' });\n    }\n    \n    const call = callQuery.rows[0];\n    \n    // Create incident\n    const incidentId = uuidv4();\n    const incidentNumber = `VOICE-${Date.now()}`;\n    \n    await pool.query(`\n      INSERT INTO incidents (\n        id, incident_number, title, description, incident_type,\n        priority, reported_at, location, reported_by,\n        voice_generated, voice_call_id, caller_phone, caller_name,\n        call_duration_seconds, call_transcript, ai_responses,\n        ai_confidence_score, created_at\n      ) VALUES (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18\n      )\n    `, [\n      incidentId,\n      incidentNumber,\n      `Voice Call - ${incident_type}`,\n      description,\n      incident_type,\n      priority,\n      call.started_at,\n      location,\n      'voice_ai_system', // Special system user\n      true, // voice_generated\n      call.call_id,\n      call.caller_phone,\n      caller_name,\n      call.duration_seconds,\n      JSON.stringify(call.transcript || []),\n      JSON.stringify(call.ai_responses || []),\n      0.8, // Default confidence score\n      new Date()\n    ]);\n    \n    // Update call log\n    await pool.query(\n      'UPDATE call_logs SET incident_created = TRUE, incident_id = $1 WHERE call_id = $2',\n      [incidentId, call_id]\n    );\n    \n    // Emit real-time notification\n    emitSocketEvent('voice_incident_created', {\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      call_id: call_id,\n      caller_phone: call.caller_phone,\n      incident_type,\n      priority,\n      timestamp: new Date().toISOString()\n    });\n    \n    res.json({\n      success: true,\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      message: 'Incident created from voice call'\n    });\n    \n  } catch (error) {\n    console.error('❌ Voice incident creation error:', error);\n    res.status(500).json({\n      error: 'Failed to create incident from voice call',\n      details: error.message\n    });\n  }\n});\n\n/**\n * STANDARD OPERATING PROCEDURES (SOP) MANAGEMENT\n * ===============================================\n * Manage SOPs for different incident types\n */\n\n/**\n * GET /api/voice/sop\n * Get all Standard Operating Procedures\n */\nrouter.get('/sop', async (req, res) => {\n  try {\n    const { property_id, incident_type } = req.query;\n    \n    let query = 'SELECT * FROM standard_operating_procedures WHERE active = TRUE';\n    const params = [];\n    \n    if (property_id) {\n      params.push(property_id);\n      query += ` AND property_id = $${params.length}`;\n    }\n    \n    if (incident_type) {\n      params.push(incident_type);\n      query += ` AND incident_type = $${params.length}`;\n    }\n    \n    query += ' ORDER BY property_id, incident_type, priority';\n    \n    const result = await pool.query(query, params);\n    \n    res.json({\n      success: true,\n      sops: result.rows,\n      total: result.rows.length\n    });\n    \n  } catch (error) {\n    console.error('❌ Get SOPs error:', error);\n    res.status(500).json({\n      error: 'Failed to get SOPs',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/voice/sop\n * Create new Standard Operating Procedure\n */\nrouter.post('/sop', async (req, res) => {\n  try {\n    const {\n      property_id,\n      incident_type,\n      priority,\n      actions,\n      contact_list,\n      escalation_rules,\n      script_template,\n      response_time_minutes\n    } = req.body;\n    \n    const sopId = `sop_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    await pool.query(`\n      INSERT INTO standard_operating_procedures (\n        sop_id, property_id, incident_type, priority, actions,\n        contact_list, escalation_rules, script_template,\n        response_time_minutes, created_at, updated_at\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n    `, [\n      sopId,\n      property_id,\n      incident_type,\n      priority,\n      JSON.stringify(actions),\n      JSON.stringify(contact_list),\n      JSON.stringify(escalation_rules),\n      script_template,\n      response_time_minutes,\n      new Date(),\n      new Date()\n    ]);\n    \n    res.json({\n      success: true,\n      sop_id: sopId,\n      message: 'SOP created successfully'\n    });\n    \n  } catch (error) {\n    console.error('❌ Create SOP error:', error);\n    res.status(500).json({\n      error: 'Failed to create SOP',\n      details: error.message\n    });\n  }\n});\n\n/**\n * HELPER FUNCTIONS\n * ================\n * Supporting functions for voice processing\n */\n\nasync function generateAIResponse(call, speechInput) {\n  try {\n    // This would integrate with the Voice AI Agent\n    // For now, return a simple response based on keywords\n    \n    const input = speechInput.toLowerCase();\n    \n    if (input.includes('emergency') || input.includes('urgent')) {\n      return 'I understand this is urgent. I\\'m dispatching emergency assistance immediately. Can you provide your exact location?';\n    } else if (input.includes('noise') || input.includes('loud')) {\n      return 'I understand there\\'s a noise issue. Can you tell me which unit or area this is coming from?';\n    } else if (input.includes('security') || input.includes('suspicious')) {\n      return 'Thank you for reporting this security concern. Can you describe what you observed and the location?';\n    } else if (input.includes('lock') || input.includes('locked out')) {\n      return 'I can help with lockout assistance. Can you confirm your unit number and provide identification?';\n    } else {\n      return 'I understand. Can you provide more details about the situation and your exact location?';\n    }\n    \n  } catch (error) {\n    console.error('❌ AI response generation error:', error);\n    return 'I\\'m here to help. Please provide more details about your situation.';\n  }\n}\n\nfunction shouldCreateIncident(transcript) {\n  try {\n    // Simple logic to determine if we have enough info for an incident\n    if (!transcript || transcript.length < 3) {\n      return false;\n    }\n    \n    const fullText = transcript\n      .filter(entry => entry.speaker === 'caller')\n      .map(entry => entry.message)\n      .join(' ')\n      .toLowerCase();\n    \n    // Check for incident indicators\n    const incidentKeywords = [\n      'emergency', 'security', 'noise', 'locked out', 'suspicious',\n      'unit', 'apartment', 'building', 'floor', 'help'\n    ];\n    \n    const hasKeywords = incidentKeywords.some(keyword => fullText.includes(keyword));\n    const hasLocationInfo = /\\b(unit|apartment|floor|building)\\s*\\d+/.test(fullText);\n    \n    return hasKeywords && (hasLocationInfo || transcript.length >= 5);\n    \n  } catch (error) {\n    console.error('❌ Incident creation check error:', error);\n    return false;\n  }\n}\n\nasync function createIncidentFromCall(call) {\n  try {\n    // Extract incident information from call transcript\n    const transcript = call.transcript || [];\n    const callerMessages = transcript\n      .filter(entry => entry.speaker === 'caller')\n      .map(entry => entry.message)\n      .join(' ');\n    \n    // Determine incident type\n    let incidentType = 'general_inquiry';\n    let priority = 'medium';\n    \n    const lowerText = callerMessages.toLowerCase();\n    \n    if (lowerText.includes('emergency') || lowerText.includes('urgent')) {\n      incidentType = 'emergency';\n      priority = 'critical';\n    } else if (lowerText.includes('security') || lowerText.includes('suspicious')) {\n      incidentType = 'security_incident';\n      priority = 'high';\n    } else if (lowerText.includes('noise') || lowerText.includes('loud')) {\n      incidentType = 'noise_complaint';\n      priority = 'medium';\n    } else if (lowerText.includes('lock') || lowerText.includes('locked')) {\n      incidentType = 'lockout';\n      priority = 'low';\n    }\n    \n    // Create incident\n    const incidentId = uuidv4();\n    const incidentNumber = `VOICE-${Date.now()}`;\n    \n    await pool.query(`\n      INSERT INTO incidents (\n        id, incident_number, title, description, incident_type,\n        priority, reported_at, reported_by,\n        voice_generated, voice_call_id, caller_phone,\n        call_duration_seconds, call_transcript,\n        ai_confidence_score, created_at\n      ) VALUES (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15\n      )\n    `, [\n      incidentId,\n      incidentNumber,\n      `Voice Call - ${incidentType}`,\n      callerMessages.substring(0, 500),\n      incidentType,\n      priority,\n      call.started_at,\n      'voice_ai_system',\n      true,\n      call.call_id,\n      call.caller_phone,\n      call.duration_seconds || 0,\n      JSON.stringify(transcript),\n      0.7, // Default confidence\n      new Date()\n    ]);\n    \n    // Emit notification\n    emitSocketEvent('voice_incident_auto_created', {\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      call_id: call.call_id,\n      incident_type,\n      priority,\n      caller_phone: call.caller_phone,\n      timestamp: new Date().toISOString()\n    });\n    \n    return incidentId;\n    \n  } catch (error) {\n    console.error('❌ Auto incident creation error:', error);\n    return null;\n  }\n}\n\nexport default router;", "newText": "/**\n * VOICE AI DISPATCHER ROUTES - MASTER PROMPT v49.0\n * ==================================================\n * Revolutionary Voice AI Dispatcher API endpoints\n * \n * Features:\n * - Twilio webhook handling for inbound calls\n * - Real-time call management and monitoring\n * - Voice-generated incident creation\n * - Human takeover capabilities\n * - Call transcription and recording management\n * - Standard Operating Procedures (SOP) management\n * - Emergency services dispatch integration\n */\n\nimport express from 'express';\nimport { getIO, emitSocketEvent } from '../../src/socket.js';\nimport pkg from 'pg';\nconst { Pool } = pkg;\nimport dotenv from 'dotenv';\nimport twilio from 'twilio';\nimport { v4 as uuidv4 } from 'uuid';\n\ndotenv.config();\nconst router = express.Router();\n\n// PostgreSQL connection pool\nconst pool = new Pool({\n  user: process.env.PG_USER,\n  host: process.env.PG_HOST,\n  database: process.env.PG_DB,\n  password: process.env.PG_PASSWORD,\n  port: Number(process.env.PG_PORT),\n});\n\n// Twilio configuration\nconst accountSid = process.env.TWILIO_ACCOUNT_SID;\nconst authToken = process.env.TWILIO_AUTH_TOKEN;\nconst twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER;\nconst twilioClient = twilio(accountSid, authToken);\n\n// Middleware to parse Twilio webhooks\nrouter.use(express.urlencoded({ extended: false }));\n\n/**\n * TWILIO WEBHOOK HANDLERS\n * =======================\n * Handle inbound calls and call status updates\n */\n\n/**\n * POST /api/voice/webhook/incoming\n * Twilio webhook for incoming calls\n */\nrouter.post('/webhook/incoming', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      From: callerPhone,\n      To: twilioNumber,\n      CallStatus,\n      Direction\n    } = req.body;\n\n    console.log(`📞 Incoming call: ${CallSid} from ${callerPhone}`);\n\n    // Create TwiML response to answer and start processing\n    const twiml = new twilio.twiml.VoiceResponse();\n    \n    // Initial greeting\n    twiml.say({\n      voice: 'Polly.Joanna',\n      language: 'en-US'\n    }, 'Hello, this is APEX AI Security Dispatch. Please hold while I connect you.');\n    \n    // Start call recording\n    twiml.record({\n      action: '/api/voice/webhook/recording',\n      method: 'POST',\n      transcribe: true,\n      transcribeCallback: '/api/voice/webhook/transcription',\n      maxLength: 600, // 10 minutes max\n      playBeep: false\n    });\n    \n    // Gather speech input\n    const gather = twiml.gather({\n      input: 'speech',\n      action: '/api/voice/webhook/speech',\n      method: 'POST',\n      speechTimeout: 'auto',\n      enhanced: true\n    });\n    \n    gather.say({\n      voice: 'Polly.Joanna'\n    }, 'Please describe the nature of your security concern or emergency.');\n    \n    // Fallback if no speech detected\n    twiml.say('I didn\\'t hear a response. Please try again.');\n    twiml.redirect('/api/voice/webhook/speech');\n\n    // Create call log in database\n    const callId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    try {\n      await pool.query(`\n        INSERT INTO call_logs (\n          call_id, twilio_call_sid, caller_phone, call_type, status,\n          started_at, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7)\n      `, [\n        callId,\n        CallSid,\n        callerPhone,\n        'general_inquiry',\n        'answered',\n        new Date(),\n        new Date()\n      ]);\n      \n      console.log(`📋 Call log created: ${callId}`);\n    } catch (dbError) {\n      console.error('❌ Database call log error:', dbError);\n    }\n\n    // Notify Voice AI Agent via WebSocket\n    emitSocketEvent('voice_call_incoming', {\n      call_id: callId,\n      twilio_call_sid: CallSid,\n      caller_phone: callerPhone,\n      status: 'answered',\n      timestamp: new Date().toISOString()\n    });\n\n    // Send TwiML response\n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Incoming call webhook error:', error);\n    \n    // Error fallback TwiML\n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('I\\'m sorry, there\\'s a technical issue. Please call back in a moment.');\n    errorTwiml.hangup();\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * POST /api/voice/webhook/speech\n * Handle speech input from caller\n */\nrouter.post('/webhook/speech', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      SpeechResult,\n      Confidence,\n      From: callerPhone\n    } = req.body;\n\n    console.log(`🎤 Speech received: ${SpeechResult} (${Confidence}% confidence)`);\n\n    // Get call from database\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE twilio_call_sid = $1',\n      [CallSid]\n    );\n    \n    if (callQuery.rows.length === 0) {\n      throw new Error(`Call not found: ${CallSid}`);\n    }\n    \n    const call = callQuery.rows[0];\n\n    // Update transcript in database\n    const currentTranscript = call.transcript || [];\n    currentTranscript.push({\n      timestamp: new Date().toISOString(),\n      speaker: 'caller',\n      message: SpeechResult,\n      confidence: parseFloat(Confidence) / 100\n    });\n\n    await pool.query(\n      'UPDATE call_logs SET transcript = $1, updated_at = $2 WHERE call_id = $3',\n      [JSON.stringify(currentTranscript), new Date(), call.call_id]\n    );\n\n    // Notify Voice AI Agent for processing\n    emitSocketEvent('voice_speech_received', {\n      call_id: call.call_id,\n      twilio_call_sid: CallSid,\n      transcript: SpeechResult,\n      confidence: parseFloat(Confidence) / 100,\n      timestamp: new Date().toISOString()\n    });\n\n    // Generate AI response (this would integrate with Voice AI Agent)\n    const aiResponse = await generateAIResponse(call, SpeechResult);\n\n    // Create TwiML response\n    const twiml = new twilio.twiml.VoiceResponse();\n    \n    twiml.say({\n      voice: 'Polly.Joanna'\n    }, aiResponse);\n    \n    // Continue gathering speech\n    const gather = twiml.gather({\n      input: 'speech',\n      action: '/api/voice/webhook/speech',\n      method: 'POST',\n      speechTimeout: 'auto',\n      enhanced: true\n    });\n    \n    gather.say('Please continue or provide additional details.');\n    \n    // Check if we should end the call or create incident\n    if (shouldCreateIncident(currentTranscript)) {\n      twiml.redirect('/api/voice/webhook/complete');\n    }\n\n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Speech webhook error:', error);\n    \n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('I\\'m processing your request. Please hold on.');\n    errorTwiml.redirect('/api/voice/webhook/speech');\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * POST /api/voice/webhook/recording\n * Handle call recording completion\n */\nrouter.post('/webhook/recording', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      RecordingUrl,\n      RecordingDuration\n    } = req.body;\n\n    console.log(`🎙️ Recording completed: ${RecordingUrl} (${RecordingDuration}s)`);\n\n    // Update call log with recording URL\n    await pool.query(\n      'UPDATE call_logs SET call_recording_url = $1, duration_seconds = $2 WHERE twilio_call_sid = $3',\n      [RecordingUrl, parseInt(RecordingDuration), CallSid]\n    );\n\n    // Notify system of recording completion\n    emitSocketEvent('voice_recording_complete', {\n      twilio_call_sid: CallSid,\n      recording_url: RecordingUrl,\n      duration_seconds: parseInt(RecordingDuration),\n      timestamp: new Date().toISOString()\n    });\n\n    res.sendStatus(200);\n    \n  } catch (error) {\n    console.error('❌ Recording webhook error:', error);\n    res.sendStatus(500);\n  }\n});\n\n/**\n * POST /api/voice/webhook/transcription\n * Handle call transcription completion\n */\nrouter.post('/webhook/transcription', async (req, res) => {\n  try {\n    const {\n      CallSid,\n      TranscriptionText,\n      TranscriptionStatus\n    } = req.body;\n\n    if (TranscriptionStatus === 'completed') {\n      console.log(`📝 Transcription completed for ${CallSid}`);\n      \n      // Update call log with full transcription\n      await pool.query(\n        'UPDATE call_logs SET metadata = metadata || $1 WHERE twilio_call_sid = $2',\n        [JSON.stringify({ full_transcription: TranscriptionText }), CallSid]\n      );\n    }\n\n    res.sendStatus(200);\n    \n  } catch (error) {\n    console.error('❌ Transcription webhook error:', error);\n    res.sendStatus(500);\n  }\n});\n\n/**\n * POST /api/voice/webhook/complete\n * Complete the call and create incident\n */\nrouter.post('/webhook/complete', async (req, res) => {\n  try {\n    const { CallSid } = req.body;\n\n    // Get call from database\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE twilio_call_sid = $1',\n      [CallSid]\n    );\n    \n    if (callQuery.rows.length > 0) {\n      const call = callQuery.rows[0];\n      \n      // Create incident from call\n      const incidentId = await createIncidentFromCall(call);\n      \n      if (incidentId) {\n        // Update call log\n        await pool.query(\n          'UPDATE call_logs SET incident_created = TRUE, incident_id = $1, status = $2 WHERE call_id = $3',\n          [incidentId, 'completed', call.call_id]\n        );\n        \n        // Final message to caller\n        const twiml = new twilio.twiml.VoiceResponse();\n        twiml.say({\n          voice: 'Polly.Joanna'\n        }, `Thank you for your report. I've created incident number ${incidentId.slice(-8)} and dispatched the appropriate response. You will receive a follow-up call if needed. Have a safe day.`);\n        twiml.hangup();\n        \n        res.type('text/xml');\n        res.send(twiml.toString());\n        \n        return;\n      }\n    }\n    \n    // Fallback completion\n    const twiml = new twilio.twiml.VoiceResponse();\n    twiml.say('Thank you for calling APEX AI Security. Your report has been received and appropriate action will be taken.');\n    twiml.hangup();\n    \n    res.type('text/xml');\n    res.send(twiml.toString());\n    \n  } catch (error) {\n    console.error('❌ Call completion error:', error);\n    \n    const errorTwiml = new twilio.twiml.VoiceResponse();\n    errorTwiml.say('Thank you for calling. Your report has been received.');\n    errorTwiml.hangup();\n    \n    res.type('text/xml');\n    res.send(errorTwiml.toString());\n  }\n});\n\n/**\n * CALL MANAGEMENT API ENDPOINTS\n * ==============================\n * Manage active calls and human intervention\n */\n\n/**\n * GET /api/voice/calls/active\n * Get all active voice calls\n */\nrouter.get('/calls/active', async (req, res) => {\n  try {\n    const query = `\n      SELECT \n        cl.*,\n        i.incident_number,\n        i.priority,\n        i.status as incident_status\n      FROM call_logs cl\n      LEFT JOIN incidents i ON i.id = cl.incident_id\n      WHERE cl.status IN ('answered', 'in_progress', 'gathering_info')\n      ORDER BY cl.started_at DESC\n    `;\n    \n    const result = await pool.query(query);\n    \n    res.json({\n      success: true,\n      active_calls: result.rows,\n      total_active: result.rows.length\n    });\n    \n  } catch (error) {\n    console.error('❌ Get active calls error:', error);\n    res.status(500).json({\n      error: 'Failed to get active calls',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/voice/calls/{call_id}\n * Get specific call details\n */\nrouter.get('/calls/:call_id', async (req, res) => {\n  const { call_id } = req.params;\n  \n  try {\n    const query = `\n      SELECT \n        cl.*,\n        i.incident_number,\n        i.title as incident_title,\n        i.priority,\n        i.status as incident_status\n      FROM call_logs cl\n      LEFT JOIN incidents i ON i.id = cl.incident_id\n      WHERE cl.call_id = $1\n    `;\n    \n    const result = await pool.query(query, [call_id]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Call not found' });\n    }\n    \n    res.json({\n      success: true,\n      call: result.rows[0]\n    });\n    \n  } catch (error) {\n    console.error('❌ Get call details error:', error);\n    res.status(500).json({\n      error: 'Failed to get call details',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/voice/calls/{call_id}/takeover\n * Human dispatcher takes over the call\n */\nrouter.post('/calls/:call_id/takeover', async (req, res) => {\n  const { call_id } = req.params;\n  const { dispatcher_id, reason } = req.body;\n  \n  try {\n    // Update call log\n    await pool.query(\n      `UPDATE call_logs SET \n        human_takeover = TRUE,\n        takeover_time = $1,\n        metadata = metadata || $2\n       WHERE call_id = $3`,\n      [\n        new Date(),\n        JSON.stringify({\n          takeover_dispatcher: dispatcher_id,\n          takeover_reason: reason || 'Manual intervention'\n        }),\n        call_id\n      ]\n    );\n    \n    // Get call details for Twilio transfer\n    const callQuery = await pool.query(\n      'SELECT twilio_call_sid FROM call_logs WHERE call_id = $1',\n      [call_id]\n    );\n    \n    if (callQuery.rows.length > 0) {\n      const { twilio_call_sid } = callQuery.rows[0];\n      \n      // Notify via WebSocket for real-time UI updates\n      emitSocketEvent('voice_call_takeover', {\n        call_id,\n        twilio_call_sid,\n        dispatcher_id,\n        reason,\n        timestamp: new Date().toISOString()\n      });\n      \n      // In production, you would redirect the Twilio call to human dispatcher\n      // For now, we'll just mark it as taken over\n      \n      res.json({\n        success: true,\n        message: 'Call takeover initiated',\n        call_id,\n        twilio_call_sid\n      });\n    } else {\n      res.status(404).json({ error: 'Call not found' });\n    }\n    \n  } catch (error) {\n    console.error('❌ Call takeover error:', error);\n    res.status(500).json({\n      error: 'Failed to takeover call',\n      details: error.message\n    });\n  }\n});\n\n/**\n * INCIDENT CREATION FROM VOICE CALLS\n * ===================================\n * Create structured incidents from voice calls\n */\n\n/**\n * POST /api/voice/incidents/create\n * Create incident from voice call\n */\nrouter.post('/incidents/create', async (req, res) => {\n  try {\n    const {\n      call_id,\n      incident_type,\n      priority,\n      description,\n      location,\n      caller_name\n    } = req.body;\n    \n    // Get call details\n    const callQuery = await pool.query(\n      'SELECT * FROM call_logs WHERE call_id = $1',\n      [call_id]\n    );\n    \n    if (callQuery.rows.length === 0) {\n      return res.status(404).json({ error: 'Call not found' });\n    }\n    \n    const call = callQuery.rows[0];\n    \n    // Create incident\n    const incidentId = uuidv4();\n    const incidentNumber = `VOICE-${Date.now()}`;\n    \n    await pool.query(`\n      INSERT INTO incidents (\n        id, incident_number, title, description, incident_type,\n        priority, reported_at, location, reported_by,\n        voice_generated, voice_call_id, caller_phone, caller_name,\n        call_duration_seconds, call_transcript, ai_responses,\n        ai_confidence_score, created_at\n      ) VALUES (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18\n      )\n    `, [\n      incidentId,\n      incidentNumber,\n      `Voice Call - ${incident_type}`,\n      description,\n      incident_type,\n      priority,\n      call.started_at,\n      location,\n      'voice_ai_system', // Special system user\n      true, // voice_generated\n      call.call_id,\n      call.caller_phone,\n      caller_name,\n      call.duration_seconds,\n      JSON.stringify(call.transcript || []),\n      JSON.stringify(call.ai_responses || []),\n      0.8, // Default confidence score\n      new Date()\n    ]);\n    \n    // Update call log\n    await pool.query(\n      'UPDATE call_logs SET incident_created = TRUE, incident_id = $1 WHERE call_id = $2',\n      [incidentId, call_id]\n    );\n    \n    // Emit real-time notification\n    emitSocketEvent('voice_incident_created', {\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      call_id: call_id,\n      caller_phone: call.caller_phone,\n      incident_type,\n      priority,\n      timestamp: new Date().toISOString()\n    });\n    \n    res.json({\n      success: true,\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      message: 'Incident created from voice call'\n    });\n    \n  } catch (error) {\n    console.error('❌ Voice incident creation error:', error);\n    res.status(500).json({\n      error: 'Failed to create incident from voice call',\n      details: error.message\n    });\n  }\n});\n\n/**\n * STANDARD OPERATING PROCEDURES (SOP) MANAGEMENT\n * ===============================================\n * Manage SOPs for different incident types\n */\n\n/**\n * GET /api/voice/sop\n * Get all Standard Operating Procedures\n */\nrouter.get('/sop', async (req, res) => {\n  try {\n    const { property_id, incident_type } = req.query;\n    \n    let query = 'SELECT * FROM standard_operating_procedures WHERE active = TRUE';\n    const params = [];\n    \n    if (property_id) {\n      params.push(property_id);\n      query += ` AND property_id = $${params.length}`;\n    }\n    \n    if (incident_type) {\n      params.push(incident_type);\n      query += ` AND incident_type = $${params.length}`;\n    }\n    \n    query += ' ORDER BY property_id, incident_type, priority';\n    \n    const result = await pool.query(query, params);\n    \n    res.json({\n      success: true,\n      sops: result.rows,\n      total: result.rows.length\n    });\n    \n  } catch (error) {\n    console.error('❌ Get SOPs error:', error);\n    res.status(500).json({\n      error: 'Failed to get SOPs',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/voice/sop\n * Create new Standard Operating Procedure\n */\nrouter.post('/sop', async (req, res) => {\n  try {\n    const {\n      property_id,\n      incident_type,\n      priority,\n      actions,\n      contact_list,\n      escalation_rules,\n      script_template,\n      response_time_minutes\n    } = req.body;\n    \n    const sopId = `sop_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    await pool.query(`\n      INSERT INTO standard_operating_procedures (\n        sop_id, property_id, incident_type, priority, actions,\n        contact_list, escalation_rules, script_template,\n        response_time_minutes, created_at, updated_at\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n    `, [\n      sopId,\n      property_id,\n      incident_type,\n      priority,\n      JSON.stringify(actions),\n      JSON.stringify(contact_list),\n      JSON.stringify(escalation_rules),\n      script_template,\n      response_time_minutes,\n      new Date(),\n      new Date()\n    ]);\n    \n    res.json({\n      success: true,\n      sop_id: sopId,\n      message: 'SOP created successfully'\n    });\n    \n  } catch (error) {\n    console.error('❌ Create SOP error:', error);\n    res.status(500).json({\n      error: 'Failed to create SOP',\n      details: error.message\n    });\n  }\n});\n\n/**\n * HELPER FUNCTIONS\n * ================\n * Supporting functions for voice processing\n */\n\nasync function generateAIResponse(call, speechInput) {\n  try {\n    // This would integrate with the Voice AI Agent\n    // For now, return a simple response based on keywords\n    \n    const input = speechInput.toLowerCase();\n    \n    if (input.includes('emergency') || input.includes('urgent')) {\n      return 'I understand this is urgent. I\\'m dispatching emergency assistance immediately. Can you provide your exact location?';\n    } else if (input.includes('noise') || input.includes('loud')) {\n      return 'I understand there\\'s a noise issue. Can you tell me which unit or area this is coming from?';\n    } else if (input.includes('security') || input.includes('suspicious')) {\n      return 'Thank you for reporting this security concern. Can you describe what you observed and the location?';\n    } else if (input.includes('lock') || input.includes('locked out')) {\n      return 'I can help with lockout assistance. Can you confirm your unit number and provide identification?';\n    } else {\n      return 'I understand. Can you provide more details about the situation and your exact location?';\n    }\n    \n  } catch (error) {\n    console.error('❌ AI response generation error:', error);\n    return 'I\\'m here to help. Please provide more details about your situation.';\n  }\n}\n\nfunction shouldCreateIncident(transcript) {\n  try {\n    // Simple logic to determine if we have enough info for an incident\n    if (!transcript || transcript.length < 3) {\n      return false;\n    }\n    \n    const fullText = transcript\n      .filter(entry => entry.speaker === 'caller')\n      .map(entry => entry.message)\n      .join(' ')\n      .toLowerCase();\n    \n    // Check for incident indicators\n    const incidentKeywords = [\n      'emergency', 'security', 'noise', 'locked out', 'suspicious',\n      'unit', 'apartment', 'building', 'floor', 'help'\n    ];\n    \n    const hasKeywords = incidentKeywords.some(keyword => fullText.includes(keyword));\n    const hasLocationInfo = /\\b(unit|apartment|floor|building)\\s*\\d+/.test(fullText);\n    \n    return hasKeywords && (hasLocationInfo || transcript.length >= 5);\n    \n  } catch (error) {\n    console.error('❌ Incident creation check error:', error);\n    return false;\n  }\n}\n\nasync function createIncidentFromCall(call) {\n  try {\n    // Extract incident information from call transcript\n    const transcript = call.transcript || [];\n    const callerMessages = transcript\n      .filter(entry => entry.speaker === 'caller')\n      .map(entry => entry.message)\n      .join(' ');\n    \n    // Determine incident type\n    let incidentType = 'general_inquiry';\n    let priority = 'medium';\n    \n    const lowerText = callerMessages.toLowerCase();\n    \n    if (lowerText.includes('emergency') || lowerText.includes('urgent')) {\n      incidentType = 'emergency';\n      priority = 'critical';\n    } else if (lowerText.includes('security') || lowerText.includes('suspicious')) {\n      incidentType = 'security_incident';\n      priority = 'high';\n    } else if (lowerText.includes('noise') || lowerText.includes('loud')) {\n      incidentType = 'noise_complaint';\n      priority = 'medium';\n    } else if (lowerText.includes('lock') || lowerText.includes('locked')) {\n      incidentType = 'lockout';\n      priority = 'low';\n    }\n    \n    // Create incident\n    const incidentId = uuidv4();\n    const incidentNumber = `VOICE-${Date.now()}`;\n    \n    await pool.query(`\n      INSERT INTO incidents (\n        id, incident_number, title, description, incident_type,\n        priority, reported_at, reported_by,\n        voice_generated, voice_call_id, caller_phone,\n        call_duration_seconds, call_transcript,\n        ai_confidence_score, created_at\n      ) VALUES (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15\n      )\n    `, [\n      incidentId,\n      incidentNumber,\n      `Voice Call - ${incidentType}`,\n      callerMessages.substring(0, 500),\n      incidentType,\n      priority,\n      call.started_at,\n      'voice_ai_system',\n      true,\n      call.call_id,\n      call.caller_phone,\n      call.duration_seconds || 0,\n      JSON.stringify(transcript),\n      0.7, // Default confidence\n      new Date()\n    ]);\n    \n    // Emit notification\n    emitSocketEvent('voice_incident_auto_created', {\n      incident_id: incidentId,\n      incident_number: incidentNumber,\n      call_id: call.call_id,\n      incident_type,\n      priority,\n      caller_phone: call.caller_phone,\n      timestamp: new Date().toISOString()\n    });\n    \n    return incidentId;\n    \n  } catch (error) {\n    console.error('❌ Auto incident creation error:', error);\n    return null;\n  }\n}\n\nexport default router;"}, {"oldText": "", "newText": ""}]