/**\n * APEX AI FACE MANAGEMENT API ROUTES\n * ==================================\n * Complete face recognition management system\n * \n * Features:\n * - Face enrollment and management\n * - Bulk face upload processing\n * - Face recognition analytics\n * - Integration with AI alert system\n */\n\nimport express from 'express';\nimport multer from 'multer';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport pkg from 'pg';\nconst { Pool } = pkg;\nimport dotenv from 'dotenv';\nimport { spawn } from 'child_process';\nimport crypto from 'crypto';\nimport sharp from 'sharp';\n\ndotenv.config();\nconst router = express.Router();\n\n// PostgreSQL connection pool\nconst pool = new Pool({\n  user: process.env.PG_USER,\n  host: process.env.PG_HOST,\n  database: process.env.PG_DB,\n  password: process.env.PG_PASSWORD,\n  port: Number(process.env.PG_PORT),\n});\n\n// Configure multer for face image uploads\nconst storage = multer.diskStorage({\n  destination: async (req, file, cb) => {\n    const uploadDir = path.join(process.cwd(), 'uploads', 'faces');\n    try {\n      await fs.mkdir(uploadDir, { recursive: true });\n      cb(null, uploadDir);\n    } catch (error) {\n      cb(error, null);\n    }\n  },\n  filename: (req, file, cb) => {\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    const ext = path.extname(file.originalname);\n    cb(null, `face-${uniqueSuffix}${ext}`);\n  }\n});\n\nconst upload = multer({\n  storage: storage,\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB limit\n    files: 20 // Max 20 files per request\n  },\n  fileFilter: (req, file, cb) => {\n    // Accept only image files\n    if (file.mimetype.startsWith('image/')) {\n      cb(null, true);\n    } else {\n      cb(new Error('Only image files are allowed'), false);\n    }\n  }\n});\n\n/**\n * Face enrollment utilities\n */\nclass FaceEnrollmentService {\n  /**\n   * Process face enrollment using Python script\n   */\n  static async enrollFaceFromImage(imagePath, personData) {\n    return new Promise((resolve, reject) => {\n      const pythonScript = path.join(process.cwd(), '..', 'apex_ai_engine', 'face_enrollment.py');\n      \n      const pythonProcess = spawn('python', [\n        pythonScript,\n        '--image', imagePath,\n        '--name', personData.person_name,\n        '--type', personData.person_type,\n        '--property_id', personData.property_id.toString(),\n        '--added_by', personData.added_by?.toString() || '1'\n      ]);\n      \n      let output = '';\n      let error = '';\n      \n      pythonProcess.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n      \n      pythonProcess.stderr.on('data', (data) => {\n        error += data.toString();\n      });\n      \n      pythonProcess.on('close', (code) => {\n        if (code === 0) {\n          try {\n            const result = JSON.parse(output);\n            resolve(result);\n          } catch (e) {\n            resolve({ success: true, face_id: null, message: 'Enrollment completed' });\n          }\n        } else {\n          reject(new Error(error || `Python process exited with code ${code}`));\n        }\n      });\n    });\n  }\n  \n  /**\n   * Validate and optimize face image\n   */\n  static async processImage(imagePath) {\n    try {\n      const metadata = await sharp(imagePath).metadata();\n      \n      // Resize if too large\n      if (metadata.width > 1024 || metadata.height > 1024) {\n        const outputPath = imagePath.replace(/\\.([^.]+)$/, '_processed.$1');\n        \n        await sharp(imagePath)\n          .resize(1024, 1024, { fit: 'inside', withoutEnlargement: true })\n          .jpeg({ quality: 90 })\n          .toFile(outputPath);\n        \n        // Replace original with processed\n        await fs.rename(outputPath, imagePath);\n      }\n      \n      return {\n        width: metadata.width,\n        height: metadata.height,\n        size: (await fs.stat(imagePath)).size\n      };\n    } catch (error) {\n      throw new Error(`Image processing failed: ${error.message}`);\n    }\n  }\n}\n\n/**\n * POST /api/faces/enroll\n * Enroll a single face\n */\nrouter.post('/enroll', upload.single('face_image'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'Face image is required' });\n    }\n    \n    const { person_name, person_type, property_id, access_level, employee_id, unit_number, notes } = req.body;\n    \n    // Validate required fields\n    if (!person_name || !person_type) {\n      return res.status(400).json({ error: 'Person name and type are required' });\n    }\n    \n    // Process image\n    const imageInfo = await FaceEnrollmentService.processImage(req.file.path);\n    \n    // Prepare person data\n    const personData = {\n      person_name,\n      person_type,\n      property_id: property_id ? parseInt(property_id) : null,\n      access_level: access_level || 'basic',\n      employee_id,\n      unit_number,\n      notes,\n      added_by: req.user?.user_id || null\n    };\n    \n    // Enroll face using Python service\n    const enrollmentResult = await FaceEnrollmentService.enrollFaceFromImage(\n      req.file.path,\n      personData\n    );\n    \n    if (enrollmentResult.success) {\n      // Store additional metadata in database\n      const insertQuery = `\n        UPDATE face_profiles \n        SET access_level = $1, employee_id = $2, unit_number = $3, \n            notes = $4, face_image_path = $5, metadata = $6\n        WHERE face_id = $7\n        RETURNING *\n      `;\n      \n      const metadata = {\n        image_info: imageInfo,\n        enrollment_timestamp: new Date().toISOString(),\n        original_filename: req.file.originalname\n      };\n      \n      if (enrollmentResult.face_id) {\n        const result = await pool.query(insertQuery, [\n          personData.access_level,\n          personData.employee_id,\n          personData.unit_number,\n          personData.notes,\n          req.file.path,\n          JSON.stringify(metadata),\n          enrollmentResult.face_id\n        ]);\n        \n        res.status(201).json({\n          success: true,\n          face_profile: result.rows[0],\n          enrollment_result: enrollmentResult,\n          message: `Face enrolled successfully for ${person_name}`\n        });\n      } else {\n        res.status(400).json({\n          success: false,\n          error: enrollmentResult.message || 'Face enrollment failed',\n          details: enrollmentResult\n        });\n      }\n    } else {\n      res.status(400).json({\n        success: false,\n        error: 'Face enrollment failed',\n        details: enrollmentResult\n      });\n    }\n    \n  } catch (error) {\n    console.error('Face enrollment error:', error);\n    \n    // Clean up uploaded file on error\n    if (req.file && req.file.path) {\n      try {\n        await fs.unlink(req.file.path);\n      } catch (unlinkError) {\n        console.error('Failed to clean up file:', unlinkError);\n      }\n    }\n    \n    res.status(500).json({\n      error: 'Face enrollment failed',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/faces/bulk-enroll\n * Bulk face enrollment\n */\nrouter.post('/bulk-enroll', upload.array('face_images', 20), async (req, res) => {\n  try {\n    if (!req.files || req.files.length === 0) {\n      return res.status(400).json({ error: 'At least one face image is required' });\n    }\n    \n    const { session_name, property_id, default_person_type, default_access_level } = req.body;\n    \n    // Create enrollment session\n    const sessionQuery = `\n      INSERT INTO face_enrollment_sessions (session_name, property_id, created_by)\n      VALUES ($1, $2, $3)\n      RETURNING session_id\n    `;\n    \n    const sessionResult = await pool.query(sessionQuery, [\n      session_name || `Bulk Upload ${new Date().toISOString()}`,\n      property_id ? parseInt(property_id) : null,\n      req.user?.user_id || null\n    ]);\n    \n    const sessionId = sessionResult.rows[0].session_id;\n    \n    const enrollmentResults = [];\n    let successCount = 0;\n    let failureCount = 0;\n    \n    // Process each file\n    for (const file of req.files) {\n      try {\n        // Extract person name from filename (basic approach)\n        const baseName = path.basename(file.originalname, path.extname(file.originalname));\n        const personName = baseName.replace(/[_-]/g, ' ').replace(/\\d+/g, '').trim();\n        \n        if (!personName) {\n          throw new Error('Could not extract person name from filename');\n        }\n        \n        // Process image\n        await FaceEnrollmentService.processImage(file.path);\n        \n        // Prepare person data\n        const personData = {\n          person_name: personName,\n          person_type: default_person_type || 'visitor',\n          property_id: property_id ? parseInt(property_id) : null,\n          access_level: default_access_level || 'basic',\n          added_by: req.user?.user_id || null\n        };\n        \n        // Enroll face\n        const result = await FaceEnrollmentService.enrollFaceFromImage(file.path, personData);\n        \n        enrollmentResults.push({\n          filename: file.originalname,\n          person_name: personName,\n          success: result.success,\n          face_id: result.face_id,\n          message: result.message\n        });\n        \n        if (result.success) {\n          successCount++;\n        } else {\n          failureCount++;\n        }\n        \n      } catch (error) {\n        enrollmentResults.push({\n          filename: file.originalname,\n          success: false,\n          error: error.message\n        });\n        failureCount++;\n        \n        // Clean up failed file\n        try {\n          await fs.unlink(file.path);\n        } catch (unlinkError) {\n          console.error('Failed to clean up file:', unlinkError);\n        }\n      }\n    }\n    \n    // Update session statistics\n    await pool.query(\n      `UPDATE face_enrollment_sessions \n       SET faces_processed = $1, faces_enrolled = $2, faces_rejected = $3, \n           status = 'completed', completed_at = CURRENT_TIMESTAMP\n       WHERE session_id = $4`,\n      [req.files.length, successCount, failureCount, sessionId]\n    );\n    \n    res.json({\n      success: true,\n      session_id: sessionId,\n      summary: {\n        total_files: req.files.length,\n        successful_enrollments: successCount,\n        failed_enrollments: failureCount\n      },\n      results: enrollmentResults\n    });\n    \n  } catch (error) {\n    console.error('Bulk enrollment error:', error);\n    \n    // Clean up all uploaded files on error\n    if (req.files) {\n      for (const file of req.files) {\n        try {\n          await fs.unlink(file.path);\n        } catch (unlinkError) {\n          console.error('Failed to clean up file:', unlinkError);\n        }\n      }\n    }\n    \n    res.status(500).json({\n      error: 'Bulk enrollment failed',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/faces\n * Get all face profiles with filtering\n */\nrouter.get('/', async (req, res) => {\n  try {\n    const { \n      person_type, \n      status, \n      property_id, \n      search, \n      limit = 50, \n      offset = 0,\n      order_by = 'created_at',\n      order_direction = 'DESC'\n    } = req.query;\n    \n    let query = `\n      SELECT \n        fp.*,\n        COUNT(fd.detection_id) as recent_detections,\n        MAX(fd.timestamp) as last_detection\n      FROM face_profiles fp\n      LEFT JOIN face_detections fd ON fp.face_id = fd.face_id \n        AND fd.timestamp >= NOW() - INTERVAL '30 days'\n      WHERE 1=1\n    `;\n    \n    const params = [];\n    let paramCount = 0;\n    \n    if (person_type) {\n      paramCount++;\n      query += ` AND fp.person_type = $${paramCount}`;\n      params.push(person_type);\n    }\n    \n    if (status) {\n      paramCount++;\n      query += ` AND fp.status = $${paramCount}`;\n      params.push(status);\n    }\n    \n    if (property_id) {\n      paramCount++;\n      query += ` AND fp.property_id = $${paramCount}`;\n      params.push(parseInt(property_id));\n    }\n    \n    if (search) {\n      paramCount++;\n      query += ` AND (fp.person_name ILIKE $${paramCount} OR fp.employee_id ILIKE $${paramCount})`;\n      params.push(`%${search}%`);\n    }\n    \n    query += ` GROUP BY fp.face_id`;\n    query += ` ORDER BY fp.${order_by} ${order_direction}`;\n    query += ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;\n    params.push(parseInt(limit), parseInt(offset));\n    \n    const result = await pool.query(query, params);\n    \n    // Get total count for pagination\n    let countQuery = 'SELECT COUNT(*) FROM face_profiles fp WHERE 1=1';\n    const countParams = [];\n    let countParamCount = 0;\n    \n    if (person_type) {\n      countParamCount++;\n      countQuery += ` AND fp.person_type = $${countParamCount}`;\n      countParams.push(person_type);\n    }\n    \n    if (status) {\n      countParamCount++;\n      countQuery += ` AND fp.status = $${countParamCount}`;\n      countParams.push(status);\n    }\n    \n    if (property_id) {\n      countParamCount++;\n      countQuery += ` AND fp.property_id = $${countParamCount}`;\n      countParams.push(parseInt(property_id));\n    }\n    \n    if (search) {\n      countParamCount++;\n      countQuery += ` AND (fp.person_name ILIKE $${countParamCount} OR fp.employee_id ILIKE $${countParamCount})`;\n      countParams.push(`%${search}%`);\n    }\n    \n    const countResult = await pool.query(countQuery, countParams);\n    const totalCount = parseInt(countResult.rows[0].count);\n    \n    res.json({\n      success: true,\n      faces: result.rows,\n      pagination: {\n        total: totalCount,\n        limit: parseInt(limit),\n        offset: parseInt(offset),\n        has_more: (parseInt(offset) + parseInt(limit)) < totalCount\n      }\n    });\n    \n  } catch (error) {\n    console.error('Face profiles fetch error:', error);\n    res.status(500).json({\n      error: 'Failed to fetch face profiles',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/faces/{face_id}\n * Get specific face profile details\n */\nrouter.get('/:face_id', async (req, res) => {\n  try {\n    const { face_id } = req.params;\n    \n    const query = `\n      SELECT \n        fp.*,\n        COUNT(fd.detection_id) as total_detections_all_time,\n        COUNT(CASE WHEN fd.timestamp >= NOW() - INTERVAL '7 days' THEN 1 END) as detections_last_week,\n        COUNT(CASE WHEN fd.timestamp >= NOW() - INTERVAL '30 days' THEN 1 END) as detections_last_month,\n        MAX(fd.timestamp) as last_detection,\n        AVG(fd.confidence) as avg_confidence\n      FROM face_profiles fp\n      LEFT JOIN face_detections fd ON fp.face_id = fd.face_id\n      WHERE fp.face_id = $1\n      GROUP BY fp.face_id\n    `;\n    \n    const result = await pool.query(query, [parseInt(face_id)]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Face profile not found' });\n    }\n    \n    // Get recent detections\n    const detectionsQuery = `\n      SELECT \n        fd.*,\n        c.name as camera_name,\n        c.location as camera_location\n      FROM face_detections fd\n      LEFT JOIN cameras c ON fd.camera_id = c.camera_id\n      WHERE fd.face_id = $1\n      ORDER BY fd.timestamp DESC\n      LIMIT 20\n    `;\n    \n    const detectionsResult = await pool.query(detectionsQuery, [parseInt(face_id)]);\n    \n    res.json({\n      success: true,\n      face_profile: result.rows[0],\n      recent_detections: detectionsResult.rows\n    });\n    \n  } catch (error) {\n    console.error('Face profile detail error:', error);\n    res.status(500).json({\n      error: 'Failed to fetch face profile details',\n      details: error.message\n    });\n  }\n});\n\n/**\n * PUT /api/faces/{face_id}\n * Update face profile\n */\nrouter.put('/:face_id', async (req, res) => {\n  try {\n    const { face_id } = req.params;\n    const { \n      person_name, \n      person_type, \n      access_level, \n      status, \n      employee_id, \n      unit_number, \n      contact_phone, \n      notes,\n      confidence_threshold \n    } = req.body;\n    \n    const updateQuery = `\n      UPDATE face_profiles \n      SET \n        person_name = COALESCE($2, person_name),\n        person_type = COALESCE($3, person_type),\n        access_level = COALESCE($4, access_level),\n        status = COALESCE($5, status),\n        employee_id = COALESCE($6, employee_id),\n        unit_number = COALESCE($7, unit_number),\n        contact_phone = COALESCE($8, contact_phone),\n        notes = COALESCE($9, notes),\n        confidence_threshold = COALESCE($10, confidence_threshold),\n        updated_at = CURRENT_TIMESTAMP\n      WHERE face_id = $1\n      RETURNING *\n    `;\n    \n    const result = await pool.query(updateQuery, [\n      parseInt(face_id),\n      person_name,\n      person_type,\n      access_level,\n      status,\n      employee_id,\n      unit_number,\n      contact_phone,\n      notes,\n      confidence_threshold ? parseFloat(confidence_threshold) : null\n    ]);\n    \n    if (result.rows.length === 0) {\n      return res.status(404).json({ error: 'Face profile not found' });\n    }\n    \n    res.json({\n      success: true,\n      face_profile: result.rows[0],\n      message: 'Face profile updated successfully'\n    });\n    \n  } catch (error) {\n    console.error('Face profile update error:', error);\n    res.status(500).json({\n      error: 'Failed to update face profile',\n      details: error.message\n    });\n  }\n});\n\n/**\n * DELETE /api/faces/{face_id}\n * Delete face profile\n */\nrouter.delete('/:face_id', async (req, res) => {\n  try {\n    const { face_id } = req.params;\n    \n    // Get face profile to clean up image file\n    const faceQuery = 'SELECT face_image_path FROM face_profiles WHERE face_id = $1';\n    const faceResult = await pool.query(faceQuery, [parseInt(face_id)]);\n    \n    if (faceResult.rows.length === 0) {\n      return res.status(404).json({ error: 'Face profile not found' });\n    }\n    \n    const imagePath = faceResult.rows[0].face_image_path;\n    \n    // Delete face profile (cascades to detections)\n    const deleteQuery = 'DELETE FROM face_profiles WHERE face_id = $1 RETURNING *';\n    const result = await pool.query(deleteQuery, [parseInt(face_id)]);\n    \n    // Clean up image file\n    if (imagePath) {\n      try {\n        await fs.unlink(imagePath);\n      } catch (unlinkError) {\n        console.warn('Could not delete face image file:', unlinkError.message);\n      }\n    }\n    \n    res.json({\n      success: true,\n      deleted_face: result.rows[0],\n      message: 'Face profile deleted successfully'\n    });\n    \n  } catch (error) {\n    console.error('Face profile deletion error:', error);\n    res.status(500).json({\n      error: 'Failed to delete face profile',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/faces/analytics/summary\n * Get face recognition analytics summary\n */\nrouter.get('/analytics/summary', async (req, res) => {\n  try {\n    const { property_id, days = 30 } = req.query;\n    \n    // Face profiles summary\n    let profilesQuery = `\n      SELECT \n        person_type,\n        status,\n        COUNT(*) as count\n      FROM face_profiles\n      WHERE 1=1\n    `;\n    \n    const params = [];\n    let paramCount = 0;\n    \n    if (property_id) {\n      paramCount++;\n      profilesQuery += ` AND property_id = $${paramCount}`;\n      params.push(parseInt(property_id));\n    }\n    \n    profilesQuery += ' GROUP BY person_type, status ORDER BY person_type, status';\n    \n    const profilesResult = await pool.query(profilesQuery, params);\n    \n    // Detection statistics\n    let detectionsQuery = `\n      SELECT \n        DATE_TRUNC('day', fd.timestamp) as detection_date,\n        COUNT(*) as total_detections,\n        COUNT(CASE WHEN fd.is_match = true THEN 1 END) as known_detections,\n        COUNT(CASE WHEN fd.is_match = false THEN 1 END) as unknown_detections,\n        AVG(fd.confidence) as avg_confidence\n      FROM face_detections fd\n      WHERE fd.timestamp >= NOW() - INTERVAL '${parseInt(days)} days'\n    `;\n    \n    if (property_id) {\n      detectionsQuery += ` AND fd.camera_id IN (\n        SELECT camera_id FROM cameras WHERE property_id = $${params.length + 1}\n      )`;\n      params.push(parseInt(property_id));\n    }\n    \n    detectionsQuery += ' GROUP BY DATE_TRUNC(\\'day\\', fd.timestamp) ORDER BY detection_date DESC';\n    \n    const detectionsResult = await pool.query(detectionsQuery, params);\n    \n    // Top detected persons\n    let topPersonsQuery = `\n      SELECT \n        fp.person_name,\n        fp.person_type,\n        COUNT(fd.detection_id) as detection_count,\n        MAX(fd.timestamp) as last_seen,\n        AVG(fd.confidence) as avg_confidence\n      FROM face_profiles fp\n      JOIN face_detections fd ON fp.face_id = fd.face_id\n      WHERE fd.timestamp >= NOW() - INTERVAL '${parseInt(days)} days'\n        AND fd.is_match = true\n    `;\n    \n    if (property_id) {\n      topPersonsQuery += ` AND fp.property_id = $${params.length + 1}`;\n      if (params.length === 0) params.push(parseInt(property_id));\n    }\n    \n    topPersonsQuery += `\n      GROUP BY fp.face_id, fp.person_name, fp.person_type\n      ORDER BY detection_count DESC\n      LIMIT 10\n    `;\n    \n    const topPersonsResult = await pool.query(topPersonsQuery, params);\n    \n    res.json({\n      success: true,\n      analytics: {\n        profile_summary: profilesResult.rows,\n        detection_trends: detectionsResult.rows,\n        top_detected_persons: topPersonsResult.rows,\n        summary_period_days: parseInt(days)\n      }\n    });\n    \n  } catch (error) {\n    console.error('Face analytics error:', error);\n    res.status(500).json({\n      error: 'Failed to fetch face recognition analytics',\n      details: error.message\n    });\n  }\n});\n\n/**\n * GET /api/faces/detections/recent\n * Get recent face detections\n */\nrouter.get('/detections/recent', async (req, res) => {\n  try {\n    const { limit = 50, camera_id, person_type, is_match } = req.query;\n    \n    let query = `\n      SELECT \n        fd.*,\n        fp.person_name,\n        fp.person_type,\n        fp.access_level,\n        c.name as camera_name,\n        c.location as camera_location\n      FROM face_detections fd\n      LEFT JOIN face_profiles fp ON fd.face_id = fp.face_id\n      LEFT JOIN cameras c ON fd.camera_id = c.camera_id\n      WHERE 1=1\n    `;\n    \n    const params = [];\n    let paramCount = 0;\n    \n    if (camera_id) {\n      paramCount++;\n      query += ` AND fd.camera_id = $${paramCount}`;\n      params.push(camera_id);\n    }\n    \n    if (person_type) {\n      paramCount++;\n      query += ` AND fp.person_type = $${paramCount}`;\n      params.push(person_type);\n    }\n    \n    if (is_match !== undefined) {\n      paramCount++;\n      query += ` AND fd.is_match = $${paramCount}`;\n      params.push(is_match === 'true');\n    }\n    \n    query += ` ORDER BY fd.timestamp DESC LIMIT $${paramCount + 1}`;\n    params.push(parseInt(limit));\n    \n    const result = await pool.query(query, params);\n    \n    res.json({\n      success: true,\n      detections: result.rows,\n      count: result.rows.length\n    });\n    \n  } catch (error) {\n    console.error('Recent detections error:', error);\n    res.status(500).json({\n      error: 'Failed to fetch recent detections',\n      details: error.message\n    });\n  }\n});\n\n/**\n * POST /api/faces/reload-cache\n * Reload face recognition cache\n */\nrouter.post('/reload-cache', async (req, res) => {\n  try {\n    // This would trigger the Python face recognition engine to reload its cache\n    // For now, we'll just return success\n    // In a real implementation, you'd send a signal to the AI engine\n    \n    res.json({\n      success: true,\n      message: 'Face recognition cache reload requested',\n      timestamp: new Date().toISOString()\n    });\n    \n  } catch (error) {\n    console.error('Cache reload error:', error);\n    res.status(500).json({\n      error: 'Failed to reload cache',\n      details: error.message\n    });\n  }\n});\n\nexport default router;"