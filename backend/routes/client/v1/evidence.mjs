// backend/routes/client/v1/evidence.mjs\n/**\n * Client Portal Evidence API Routes\n * =================================\n * Provides secure access to evidence files with watermarking and access controls\n * All data is automatically scoped to the authenticated client\n */\n\nimport express from 'express';\nimport rateLimit from 'express-rate-limit';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { ClientPortalQueries } from '../../../database.mjs';\nimport { \n  clientPortalAuth,\n  requireClientPermission,\n  logClientActivity \n} from '../../../middleware/clientAuth.mjs';\n\nconst router = express.Router();\n\n// Rate limiting for evidence APIs (50 requests per 5 minutes)\nconst evidenceLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 50,\n  message: {\n    error: 'Rate limit exceeded',\n    code: 'EVIDENCE_RATE_LIMIT',\n    message: 'Too many evidence requests. Please wait a moment.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Stricter rate limiting for file downloads (20 downloads per 5 minutes)\nconst downloadLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 20,\n  message: {\n    error: 'Download rate limit exceeded',\n    code: 'DOWNLOAD_RATE_LIMIT',\n    message: 'Too many file downloads. Please wait before downloading more files.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Apply authentication to all routes\nrouter.use(evidenceLimiter, ...clientPortalAuth, requireClientPermission('evidence'));\n\n/**\n * @route   GET /api/client/v1/evidence\n * @desc    Get paginated list of evidence files\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/', logClientActivity('browse_evidence', 'evidence'), async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      incidentId,\n      fileType,\n      dateFrom,\n      dateTo,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = req.query;\n    \n    const clientId = req.user.clientId;\n    const offset = (parseInt(page) - 1) * parseInt(limit);\n    \n    // Build filter conditions\n    let whereClause = 'WHERE i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true';\n    const replacements = { clientId };\n    \n    if (incidentId) {\n      whereClause += ' AND e.\"incidentId\" = :incidentId';\n      replacements.incidentId = parseInt(incidentId);\n    }\n    \n    if (fileType) {\n      whereClause += ' AND e.\"fileType\" = :fileType';\n      replacements.fileType = fileType;\n    }\n    \n    if (dateFrom) {\n      whereClause += ' AND e.\"createdAt\" >= :dateFrom';\n      replacements.dateFrom = dateFrom;\n    }\n    \n    if (dateTo) {\n      whereClause += ' AND e.\"createdAt\" <= :dateTo';\n      replacements.dateTo = dateTo;\n    }\n    \n    // Validate and set sorting\n    const allowedSortFields = ['createdAt', 'originalFileName', 'fileType', 'fileSize'];\n    const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'createdAt';\n    const order = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';\n    \n    // Get evidence files with pagination\n    const [evidenceFiles] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        e.id, e.\"incidentId\", e.\"originalFileName\", e.\"fileType\", e.\"fileSize\",\n        e.\"thumbnailPath\", e.\"watermarkPath\", e.\"createdAt\", e.\"metadata\",\n        i.\"incidentNumber\", i.\"incidentType\", i.location, i.\"incidentDate\",\n        p.name as \"propertyName\"\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      ${whereClause}\n      ORDER BY e.\"${sortField}\" ${order}\n      LIMIT :limit OFFSET :offset\n    `, {\n      replacements: { ...replacements, limit: parseInt(limit), offset },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get total count for pagination\n    const [totalCount] = await ClientPortalQueries.sequelize.query(`\n      SELECT COUNT(DISTINCT e.id) as total\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      ${whereClause}\n    `, {\n      replacements,\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    const total = parseInt(totalCount[0].total);\n    const totalPages = Math.ceil(total / parseInt(limit));\n    \n    // Format file size helper function\n    const formatFileSize = (bytes) => {\n      const units = ['B', 'KB', 'MB', 'GB'];\n      let size = bytes;\n      let unitIndex = 0;\n      \n      while (size >= 1024 && unitIndex < units.length - 1) {\n        size /= 1024;\n        unitIndex++;\n      }\n      \n      return `${Math.round(size * 10) / 10} ${units[unitIndex]}`;\n    };\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        evidenceFiles: evidenceFiles.map(file => ({\n          id: file.id,\n          incidentId: file.incidentId,\n          incidentNumber: file.incidentNumber,\n          incidentType: file.incidentType,\n          incidentDate: file.incidentDate,\n          location: file.location,\n          propertyName: file.propertyName,\n          originalFileName: file.originalFileName,\n          fileType: file.fileType,\n          fileSize: file.fileSize,\n          fileSizeFormatted: formatFileSize(file.fileSize),\n          hasThumbnail: !!file.thumbnailPath,\n          hasWatermark: !!file.watermarkPath,\n          createdAt: file.createdAt,\n          metadata: file.metadata ? JSON.parse(file.metadata) : {}\n        })),\n        pagination: {\n          currentPage: parseInt(page),\n          totalPages: totalPages,\n          totalItems: total,\n          itemsPerPage: parseInt(limit),\n          hasNextPage: parseInt(page) < totalPages,\n          hasPrevPage: parseInt(page) > 1\n        },\n        filters: {\n          incidentId: incidentId ? parseInt(incidentId) : null,\n          fileType,\n          dateFrom,\n          dateTo\n        },\n        sorting: {\n          sortBy: sortField,\n          sortOrder: order.toLowerCase()\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Evidence list error:', error);\n    res.status(500).json({\n      error: 'Evidence service error',\n      code: 'EVIDENCE_SERVICE_ERROR',\n      message: 'Unable to load evidence files. Please try again.'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/evidence/:id\n * @desc    Get detailed information for a specific evidence file\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/:id', logClientActivity('view_evidence_details', 'evidence'), async (req, res) => {\n  try {\n    const evidenceId = parseInt(req.params.id);\n    const clientId = req.user.clientId;\n    \n    if (!evidenceId || isNaN(evidenceId)) {\n      return res.status(400).json({\n        error: 'Invalid evidence ID',\n        code: 'INVALID_EVIDENCE_ID',\n        message: 'Evidence ID must be a valid number'\n      });\n    }\n    \n    // Get evidence file details with incident info\n    const [evidenceFiles] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        e.*, \n        i.\"incidentNumber\", i.\"incidentType\", i.location, i.\"incidentDate\", i.description as \"incidentDescription\",\n        p.name as \"propertyName\", p.address as \"propertyAddress\"\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      WHERE e.id = :evidenceId AND i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true\n    `, {\n      replacements: { evidenceId, clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    if (!evidenceFiles[0]) {\n      return res.status(404).json({\n        error: 'Evidence file not found',\n        code: 'EVIDENCE_NOT_FOUND',\n        message: 'The requested evidence file was not found or you do not have access to it'\n      });\n    }\n    \n    const evidence = evidenceFiles[0];\n    const metadata = evidence.metadata ? JSON.parse(evidence.metadata) : {};\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        evidence: {\n          id: evidence.id,\n          incidentId: evidence.incidentId,\n          incidentNumber: evidence.incidentNumber,\n          incidentType: evidence.incidentType,\n          incidentDate: evidence.incidentDate,\n          incidentDescription: evidence.incidentDescription,\n          location: evidence.location,\n          propertyName: evidence.propertyName,\n          propertyAddress: evidence.propertyAddress,\n          originalFileName: evidence.originalFileName,\n          fileName: evidence.fileName,\n          fileType: evidence.fileType,\n          mimeType: evidence.mimeType,\n          fileSize: evidence.fileSize,\n          fileSizeFormatted: formatFileSize(evidence.fileSize),\n          fileHash: evidence.fileHash.substring(0, 16) + '...', // Partial hash for verification\n          watermarked: evidence.watermarked,\n          hasThumbnail: !!evidence.thumbnailPath,\n          hasWatermark: !!evidence.watermarkPath,\n          metadata: metadata,\n          createdAt: evidence.createdAt,\n          updatedAt: evidence.updatedAt\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Evidence details error:', error);\n    res.status(500).json({\n      error: 'Evidence details service error',\n      code: 'EVIDENCE_DETAILS_ERROR',\n      message: 'Unable to load evidence file details'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/evidence/:id/thumbnail\n * @desc    Get thumbnail image for evidence file\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/:id/thumbnail', downloadLimiter, logClientActivity('view_evidence_thumbnail', 'evidence'), async (req, res) => {\n  try {\n    const evidenceId = parseInt(req.params.id);\n    const clientId = req.user.clientId;\n    \n    if (!evidenceId || isNaN(evidenceId)) {\n      return res.status(400).json({\n        error: 'Invalid evidence ID',\n        code: 'INVALID_EVIDENCE_ID'\n      });\n    }\n    \n    // Verify access and get thumbnail path\n    const [evidenceFiles] = await ClientPortalQueries.sequelize.query(`\n      SELECT e.\"thumbnailPath\", e.\"originalFileName\", e.\"mimeType\"\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      WHERE e.id = :evidenceId AND i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true\n    `, {\n      replacements: { evidenceId, clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    if (!evidenceFiles[0] || !evidenceFiles[0].thumbnailPath) {\n      return res.status(404).json({\n        error: 'Thumbnail not found',\n        code: 'THUMBNAIL_NOT_FOUND',\n        message: 'Thumbnail not available for this evidence file'\n      });\n    }\n    \n    const evidence = evidenceFiles[0];\n    const thumbnailPath = evidence.thumbnailPath;\n    \n    // Check if thumbnail file exists\n    try {\n      await fs.access(thumbnailPath);\n    } catch (fileError) {\n      console.error('Thumbnail file not accessible:', fileError);\n      return res.status(404).json({\n        error: 'Thumbnail file not accessible',\n        code: 'THUMBNAIL_FILE_ERROR'\n      });\n    }\n    \n    // Set appropriate headers\n    res.setHeader('Content-Type', 'image/jpeg'); // Thumbnails are typically JPEG\n    res.setHeader('Cache-Control', 'private, max-age=3600'); // Cache for 1 hour\n    res.setHeader('Content-Disposition', `inline; filename=\"thumbnail_${evidence.originalFileName}.jpg\"`);\n    \n    // Send thumbnail file\n    res.sendFile(path.resolve(thumbnailPath));\n    \n  } catch (error) {\n    console.error('Thumbnail error:', error);\n    res.status(500).json({\n      error: 'Thumbnail service error',\n      code: 'THUMBNAIL_SERVICE_ERROR',\n      message: 'Unable to load thumbnail'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/evidence/:id/download\n * @desc    Download watermarked evidence file\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/:id/download', downloadLimiter, logClientActivity('download_evidence', 'evidence'), async (req, res) => {\n  try {\n    const evidenceId = parseInt(req.params.id);\n    const clientId = req.user.clientId;\n    \n    if (!evidenceId || isNaN(evidenceId)) {\n      return res.status(400).json({\n        error: 'Invalid evidence ID',\n        code: 'INVALID_EVIDENCE_ID'\n      });\n    }\n    \n    // Verify access and get file paths\n    const [evidenceFiles] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        e.\"watermarkPath\", e.\"filePath\", e.\"originalFileName\", \n        e.\"mimeType\", e.\"fileSize\", e.\"watermarked\",\n        i.\"incidentNumber\"\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      WHERE e.id = :evidenceId AND i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true\n    `, {\n      replacements: { evidenceId, clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    if (!evidenceFiles[0]) {\n      return res.status(404).json({\n        error: 'Evidence file not found',\n        code: 'EVIDENCE_NOT_FOUND',\n        message: 'The requested evidence file was not found or you do not have access to it'\n      });\n    }\n    \n    const evidence = evidenceFiles[0];\n    \n    // Prefer watermarked version for client downloads\n    const filePath = evidence.watermarked && evidence.watermarkPath \n      ? evidence.watermarkPath \n      : evidence.filePath;\n    \n    if (!filePath) {\n      return res.status(404).json({\n        error: 'File not available',\n        code: 'FILE_NOT_AVAILABLE',\n        message: 'Evidence file is not available for download'\n      });\n    }\n    \n    // Check if file exists\n    try {\n      await fs.access(filePath);\n    } catch (fileError) {\n      console.error('Evidence file not accessible:', fileError);\n      return res.status(404).json({\n        error: 'File not accessible',\n        code: 'FILE_NOT_ACCESSIBLE',\n        message: 'Evidence file could not be accessed'\n      });\n    }\n    \n    // Create download filename with incident number\n    const timestamp = new Date().toISOString().split('T')[0];\n    const downloadFileName = `${evidence.incidentNumber}_${evidence.originalFileName}`;\n    \n    // Set appropriate headers for download\n    res.setHeader('Content-Type', evidence.mimeType);\n    res.setHeader('Content-Disposition', `attachment; filename=\"${downloadFileName}\"`);\n    res.setHeader('Cache-Control', 'private, no-cache');\n    \n    // Add watermark notice in headers\n    res.setHeader('X-Evidence-Watermarked', evidence.watermarked ? 'true' : 'false');\n    res.setHeader('X-Evidence-Source', 'APEX-AI-Security-Portal');\n    \n    // Send file\n    res.sendFile(path.resolve(filePath));\n    \n    // Log download in audit trail (async)\n    ClientPortalQueries.logClientPortalActivity(\n      req.user.id,\n      req.user.clientId,\n      'file_downloaded',\n      'evidence',\n      evidenceId,\n      { \n        fileName: evidence.originalFileName,\n        fileSize: evidence.fileSize,\n        watermarked: evidence.watermarked,\n        incidentNumber: evidence.incidentNumber\n      },\n      req.clientInfo?.ipAddress,\n      req.clientInfo?.userAgent,\n      req.clientInfo?.sessionId\n    ).catch(err => console.error('Download audit log error:', err));\n    \n  } catch (error) {\n    console.error('Evidence download error:', error);\n    res.status(500).json({\n      error: 'Download service error',\n      code: 'DOWNLOAD_SERVICE_ERROR',\n      message: 'Unable to download evidence file'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/evidence/filters/options\n * @desc    Get available filter options for evidence files\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/filters/options', logClientActivity('get_evidence_filters', 'evidence'), async (req, res) => {\n  try {\n    const clientId = req.user.clientId;\n    \n    // Get distinct file types\n    const [fileTypes] = await ClientPortalQueries.sequelize.query(`\n      SELECT DISTINCT e.\"fileType\", COUNT(*) as count\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      WHERE i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true\n      GROUP BY e.\"fileType\"\n      ORDER BY count DESC, e.\"fileType\" ASC\n    `, {\n      replacements: { clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get incidents with evidence for filtering\n    const [incidentsWithEvidence] = await ClientPortalQueries.sequelize.query(`\n      SELECT DISTINCT \n        i.id, i.\"incidentNumber\", i.\"incidentType\", i.\"incidentDate\",\n        COUNT(e.id) as \"evidenceCount\"\n      FROM \"Incidents\" i\n      JOIN \"EvidenceFiles\" e ON i.id = e.\"incidentId\"\n      WHERE i.\"clientId\" = :clientId AND e.\"isClientAccessible\" = true\n      GROUP BY i.id, i.\"incidentNumber\", i.\"incidentType\", i.\"incidentDate\"\n      ORDER BY i.\"incidentDate\" DESC\n      LIMIT 50  -- Limit to recent incidents for performance\n    `, {\n      replacements: { clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        fileTypes: fileTypes.map(type => ({\n          value: type.fileType,\n          label: type.fileType.charAt(0).toUpperCase() + type.fileType.slice(1),\n          count: parseInt(type.count)\n        })),\n        incidents: incidentsWithEvidence.map(incident => ({\n          value: incident.id,\n          label: `${incident.incidentNumber} - ${incident.incidentType}`,\n          incidentDate: incident.incidentDate,\n          evidenceCount: parseInt(incident.evidenceCount)\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Evidence filters error:', error);\n    res.status(500).json({\n      error: 'Filters service error',\n      code: 'EVIDENCE_FILTERS_ERROR',\n      message: 'Unable to load filter options'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/evidence/stats\n * @desc    Get evidence statistics and storage info\n * @access  Private (Client Portal Users with evidence permission)\n */\nrouter.get('/stats', logClientActivity('view_evidence_stats', 'evidence'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query;\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    // Get evidence statistics\n    const [stats] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        COUNT(*) as \"totalFiles\",\n        COUNT(*) FILTER (WHERE e.\"fileType\" = 'video') as \"videoFiles\",\n        COUNT(*) FILTER (WHERE e.\"fileType\" = 'image') as \"imageFiles\",\n        COUNT(*) FILTER (WHERE e.\"fileType\" = 'audio') as \"audioFiles\",\n        COUNT(*) FILTER (WHERE e.\"watermarked\" = true) as \"watermarkedFiles\",\n        COALESCE(SUM(e.\"fileSize\"), 0) as \"totalStorage\",\n        COALESCE(AVG(e.\"fileSize\"), 0) as \"avgFileSize\"\n      FROM \"EvidenceFiles\" e\n      JOIN \"Incidents\" i ON e.\"incidentId\" = i.id\n      WHERE i.\"clientId\" = :clientId \n        AND e.\"isClientAccessible\" = true\n        AND e.\"createdAt\" >= NOW() - INTERVAL :dateRange\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    const formatFileSize = (bytes) => {\n      const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n      let size = bytes;\n      let unitIndex = 0;\n      \n      while (size >= 1024 && unitIndex < units.length - 1) {\n        size /= 1024;\n        unitIndex++;\n      }\n      \n      return `${Math.round(size * 100) / 100} ${units[unitIndex]}`;\n    };\n    \n    const statsData = stats[0];\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        stats: {\n          totalFiles: parseInt(statsData.totalFiles),\n          videoFiles: parseInt(statsData.videoFiles),\n          imageFiles: parseInt(statsData.imageFiles),\n          audioFiles: parseInt(statsData.audioFiles),\n          watermarkedFiles: parseInt(statsData.watermarkedFiles),\n          totalStorage: parseInt(statsData.totalStorage),\n          totalStorageFormatted: formatFileSize(parseInt(statsData.totalStorage)),\n          avgFileSize: parseFloat(statsData.avgFileSize),\n          avgFileSizeFormatted: formatFileSize(parseFloat(statsData.avgFileSize)),\n          watermarkRate: statsData.totalFiles > 0 \n            ? Math.round((statsData.watermarkedFiles / statsData.totalFiles) * 100)\n            : 0\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Evidence stats error:', error);\n    res.status(500).json({\n      error: 'Evidence stats service error',\n      code: 'EVIDENCE_STATS_ERROR',\n      message: 'Unable to load evidence statistics'\n    });\n  }\n});\n\n// Helper function for file size formatting\nconst formatFileSize = (bytes) => {\n  const units = ['B', 'KB', 'MB', 'GB'];\n  let size = bytes;\n  let unitIndex = 0;\n  \n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n  \n  return `${Math.round(size * 10) / 10} ${units[unitIndex]}`;\n};\n\nexport default router;