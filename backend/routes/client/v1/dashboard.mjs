// backend/routes/client/v1/dashboard.mjs\n/**\n * Client Portal Dashboard API Routes\n * ==================================\n * Provides executive dashboard data, KPIs, and analytics for client portal\n * All data is automatically scoped to the authenticated client\n */\n\nimport express from 'express';\nimport rateLimit from 'express-rate-limit';\nimport { ClientPortalQueries } from '../../../database.mjs';\nimport { \n  clientPortalAuth,\n  requireClientPermission,\n  logClientActivity \n} from '../../../middleware/clientAuth.mjs';\n\nconst router = express.Router();\n\n// Rate limiting for dashboard APIs (100 requests per 5 minutes)\nconst dashboardLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 100,\n  message: {\n    error: 'Rate limit exceeded',\n    code: 'DASHBOARD_RATE_LIMIT',\n    message: 'Too many dashboard requests. Please wait a moment.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Apply authentication to all routes\nrouter.use(dashboardLimiter, ...clientPortalAuth, requireClientPermission('dashboard'));\n\n/**\n * @route   GET /api/client/v1/dashboard/overview\n * @desc    Get executive dashboard overview with KPIs\n * @access  Private (Client Portal Users with dashboard permission)\n */\nrouter.get('/overview', logClientActivity('view_dashboard_overview', 'dashboard'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query; // days\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    // Get main KPIs\n    const kpis = await ClientPortalQueries.getClientDashboardKPIs(clientId, dateRangeStr);\n    \n    // Get incident trends for the chart\n    const trends = await ClientPortalQueries.getClientIncidentTrends(clientId, dateRangeStr);\n    \n    // Get recent critical incidents\n    const recentIncidents = await ClientPortalQueries.getClientIncidents(clientId, {\n      severity: 'critical',\n      limit: 5,\n      offset: 0\n    });\n    \n    // Get property breakdown\n    const [propertyStats] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        p.id,\n        p.name as \"propertyName\",\n        COUNT(i.id) as \"incidentCount\",\n        COUNT(i.id) FILTER (WHERE i.severity IN ('high', 'critical')) as \"highSeverityCount\",\n        COALESCE(ROUND(AVG(i.\"aiConfidence\"), 2), 0) as \"avgAiConfidence\"\n      FROM \"Properties\" p\n      LEFT JOIN \"Incidents\" i ON p.id = i.\"propertyId\" \n        AND i.\"incidentDate\" >= NOW() - INTERVAL :dateRange\n      WHERE p.\"clientId\" = :clientId AND p.\"isActive\" = true\n      GROUP BY p.id, p.name\n      ORDER BY \"incidentCount\" DESC\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Calculate key metrics\n    const totalProperties = propertyStats.length;\n    const activeProperties = propertyStats.filter(p => parseInt(p.incidentCount) > 0).length;\n    const resolutionRate = kpis.totalIncidents > 0 \n      ? Math.round((kpis.resolvedIncidents / kpis.totalIncidents) * 100)\n      : 0;\n    \n    // Get AI performance metrics\n    const [aiMetrics] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        COUNT(*) as \"totalDetections\",\n        COUNT(*) FILTER (WHERE \"aiConfidence\" >= 90) as \"highConfidenceDetections\",\n        COUNT(*) FILTER (WHERE \"aiConfidence\" >= 95) as \"veryHighConfidenceDetections\",\n        ROUND(AVG(\"aiConfidence\"), 2) as \"avgConfidence\"\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId \n        AND \"incidentDate\" >= NOW() - INTERVAL :dateRange\n        AND \"aiConfidence\" IS NOT NULL\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    const response = {\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        lastUpdated: new Date().toISOString(),\n        \n        // Main KPI Cards\n        kpis: {\n          totalIncidents: parseInt(kpis.totalIncidents) || 0,\n          criticalIncidents: parseInt(kpis.criticalIncidents) || 0,\n          highIncidents: parseInt(kpis.highIncidents) || 0,\n          resolvedIncidents: parseInt(kpis.resolvedIncidents) || 0,\n          resolutionRate: resolutionRate,\n          avgAiConfidence: parseFloat(kpis.avgAIConfidence) || 0,\n          activeProperties: activeProperties,\n          totalProperties: totalProperties\n        },\n        \n        // Trend data for charts\n        trends: trends.map(trend => ({\n          date: trend.date,\n          incidents: parseInt(trend.incidentCount),\n          highSeverity: parseInt(trend.highSeverityCount)\n        })),\n        \n        // Recent critical incidents\n        recentCriticalIncidents: recentIncidents.map(incident => ({\n          id: incident.id,\n          incidentNumber: incident.incidentNumber,\n          incidentType: incident.incidentType,\n          location: incident.location,\n          propertyName: incident.propertyName,\n          incidentDate: incident.incidentDate,\n          status: incident.status,\n          aiConfidence: incident.aiConfidence\n        })),\n        \n        // Property performance breakdown\n        propertyStats: propertyStats.map(stat => ({\n          propertyId: stat.id,\n          propertyName: stat.propertyName,\n          incidentCount: parseInt(stat.incidentCount),\n          highSeverityCount: parseInt(stat.highSeverityCount),\n          avgAiConfidence: parseFloat(stat.avgAiConfidence)\n        })),\n        \n        // AI Performance metrics\n        aiPerformance: {\n          totalDetections: parseInt(aiMetrics[0]?.totalDetections) || 0,\n          highConfidenceDetections: parseInt(aiMetrics[0]?.highConfidenceDetections) || 0,\n          veryHighConfidenceDetections: parseInt(aiMetrics[0]?.veryHighConfidenceDetections) || 0,\n          avgConfidence: parseFloat(aiMetrics[0]?.avgConfidence) || 0,\n          accuracyRate: aiMetrics[0]?.totalDetections > 0 \n            ? Math.round((aiMetrics[0].highConfidenceDetections / aiMetrics[0].totalDetections) * 100)\n            : 0\n        }\n      }\n    };\n    \n    res.status(200).json(response);\n    \n  } catch (error) {\n    console.error('Dashboard overview error:', error);\n    res.status(500).json({\n      error: 'Dashboard service error',\n      code: 'DASHBOARD_SERVICE_ERROR',\n      message: 'Unable to load dashboard data. Please try again.'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/dashboard/incident-types\n * @desc    Get incident type breakdown with counts and percentages\n * @access  Private (Client Portal Users with dashboard permission)\n */\nrouter.get('/incident-types', logClientActivity('view_incident_types', 'dashboard'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query;\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    const [incidentTypes] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        \"incidentType\",\n        COUNT(*) as count,\n        ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage,\n        COUNT(*) FILTER (WHERE severity = 'critical') as \"criticalCount\",\n        COUNT(*) FILTER (WHERE severity = 'high') as \"highCount\",\n        COUNT(*) FILTER (WHERE status = 'resolved') as \"resolvedCount\",\n        COALESCE(ROUND(AVG(\"aiConfidence\"), 2), 0) as \"avgConfidence\"\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId \n        AND \"incidentDate\" >= NOW() - INTERVAL :dateRange\n      GROUP BY \"incidentType\"\n      ORDER BY count DESC\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        incidentTypes: incidentTypes.map(type => ({\n          type: type.incidentType,\n          count: parseInt(type.count),\n          percentage: parseFloat(type.percentage),\n          criticalCount: parseInt(type.criticalCount),\n          highCount: parseInt(type.highCount),\n          resolvedCount: parseInt(type.resolvedCount),\n          avgConfidence: parseFloat(type.avgConfidence),\n          resolutionRate: type.count > 0 ? Math.round((type.resolvedCount / type.count) * 100) : 0\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Incident types error:', error);\n    res.status(500).json({\n      error: 'Incident types service error',\n      code: 'INCIDENT_TYPES_ERROR',\n      message: 'Unable to load incident type data'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/dashboard/response-times\n * @desc    Get response time analytics and performance metrics\n * @access  Private (Client Portal Users with dashboard permission)\n */\nrouter.get('/response-times', logClientActivity('view_response_times', 'dashboard'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query;\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    // Overall response time stats\n    const [responseStats] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        COUNT(*) as \"totalResolved\",\n        ROUND(AVG(EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"avgResponseMinutes\",\n        ROUND(MIN(EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"minResponseMinutes\",\n        ROUND(MAX(EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"maxResponseMinutes\",\n        ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"medianResponseMinutes\",\n        ROUND(PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"p90ResponseMinutes\"\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId \n        AND \"resolvedAt\" IS NOT NULL\n        AND \"incidentDate\" >= NOW() - INTERVAL :dateRange\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Response time by incident type\n    const [responseByType] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        \"incidentType\",\n        COUNT(*) as count,\n        ROUND(AVG(EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"avgResponseMinutes\"\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId \n        AND \"resolvedAt\" IS NOT NULL\n        AND \"incidentDate\" >= NOW() - INTERVAL :dateRange\n      GROUP BY \"incidentType\"\n      HAVING COUNT(*) >= 3  -- Only include types with at least 3 resolved incidents\n      ORDER BY \"avgResponseMinutes\" ASC\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Response time trends over time\n    const [trendData] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        DATE(\"resolvedAt\") as date,\n        COUNT(*) as \"resolvedCount\",\n        ROUND(AVG(EXTRACT(EPOCH FROM (\"resolvedAt\" - \"incidentDate\"))/60), 2) as \"avgResponseMinutes\"\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId \n        AND \"resolvedAt\" IS NOT NULL\n        AND \"incidentDate\" >= NOW() - INTERVAL :dateRange\n      GROUP BY DATE(\"resolvedAt\")\n      HAVING COUNT(*) > 0\n      ORDER BY date ASC\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        overall: {\n          totalResolved: parseInt(responseStats[0]?.totalResolved) || 0,\n          avgResponseMinutes: parseFloat(responseStats[0]?.avgResponseMinutes) || 0,\n          minResponseMinutes: parseFloat(responseStats[0]?.minResponseMinutes) || 0,\n          maxResponseMinutes: parseFloat(responseStats[0]?.maxResponseMinutes) || 0,\n          medianResponseMinutes: parseFloat(responseStats[0]?.medianResponseMinutes) || 0,\n          p90ResponseMinutes: parseFloat(responseStats[0]?.p90ResponseMinutes) || 0\n        },\n        byIncidentType: responseByType.map(type => ({\n          incidentType: type.incidentType,\n          count: parseInt(type.count),\n          avgResponseMinutes: parseFloat(type.avgResponseMinutes)\n        })),\n        trends: trendData.map(trend => ({\n          date: trend.date,\n          resolvedCount: parseInt(trend.resolvedCount),\n          avgResponseMinutes: parseFloat(trend.avgResponseMinutes)\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Response times error:', error);\n    res.status(500).json({\n      error: 'Response times service error',\n      code: 'RESPONSE_TIMES_ERROR',\n      message: 'Unable to load response time data'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/dashboard/hotspots\n * @desc    Get property hotspot analysis - areas with most incidents\n * @access  Private (Client Portal Users with dashboard permission)\n */\nrouter.get('/hotspots', logClientActivity('view_hotspots', 'dashboard'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query;\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    // Property-level hotspots\n    const [propertyHotspots] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        p.id as \"propertyId\",\n        p.name as \"propertyName\",\n        p.address as \"propertyAddress\",\n        COUNT(i.id) as \"incidentCount\",\n        COUNT(i.id) FILTER (WHERE i.severity IN ('high', 'critical')) as \"highSeverityCount\",\n        STRING_AGG(DISTINCT i.\"incidentType\", ', ' ORDER BY i.\"incidentType\") as \"commonIncidentTypes\",\n        COALESCE(ROUND(AVG(i.\"aiConfidence\"), 2), 0) as \"avgConfidence\"\n      FROM \"Properties\" p\n      LEFT JOIN \"Incidents\" i ON p.id = i.\"propertyId\" \n        AND i.\"incidentDate\" >= NOW() - INTERVAL :dateRange\n      WHERE p.\"clientId\" = :clientId AND p.\"isActive\" = true\n      GROUP BY p.id, p.name, p.address\n      ORDER BY \"incidentCount\" DESC\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Location-level hotspots (within properties)\n    const [locationHotspots] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        i.location,\n        p.name as \"propertyName\",\n        COUNT(*) as \"incidentCount\",\n        COUNT(*) FILTER (WHERE i.severity IN ('high', 'critical')) as \"highSeverityCount\",\n        STRING_AGG(DISTINCT i.\"incidentType\", ', ' ORDER BY i.\"incidentType\") as \"incidentTypes\"\n      FROM \"Incidents\" i\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      WHERE i.\"clientId\" = :clientId \n        AND i.\"incidentDate\" >= NOW() - INTERVAL :dateRange\n        AND i.location IS NOT NULL \n        AND LENGTH(TRIM(i.location)) > 0\n      GROUP BY i.location, p.name\n      HAVING COUNT(*) >= 2  -- Only show locations with at least 2 incidents\n      ORDER BY \"incidentCount\" DESC\n      LIMIT 20\n    `, {\n      replacements: { clientId, dateRange: dateRangeStr },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        propertyHotspots: propertyHotspots.map(property => ({\n          propertyId: property.propertyId,\n          propertyName: property.propertyName,\n          propertyAddress: property.propertyAddress,\n          incidentCount: parseInt(property.incidentCount),\n          highSeverityCount: parseInt(property.highSeverityCount),\n          commonIncidentTypes: property.commonIncidentTypes,\n          avgConfidence: parseFloat(property.avgConfidence),\n          riskLevel: parseInt(property.incidentCount) >= 20 ? 'high' : \n                    parseInt(property.incidentCount) >= 10 ? 'medium' : 'low'\n        })),\n        locationHotspots: locationHotspots.map(location => ({\n          location: location.location,\n          propertyName: location.propertyName,\n          incidentCount: parseInt(location.incidentCount),\n          highSeverityCount: parseInt(location.highSeverityCount),\n          incidentTypes: location.incidentTypes,\n          riskLevel: parseInt(location.incidentCount) >= 10 ? 'high' : \n                    parseInt(location.incidentCount) >= 5 ? 'medium' : 'low'\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Hotspots error:', error);\n    res.status(500).json({\n      error: 'Hotspots service error',\n      code: 'HOTSPOTS_ERROR',\n      message: 'Unable to load hotspot data'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/dashboard/properties\n * @desc    Get properties overview with incident summaries\n * @access  Private (Client Portal Users with dashboard permission)\n */\nrouter.get('/properties', logClientActivity('view_properties_dashboard', 'dashboard'), async (req, res) => {\n  try {\n    const { dateRange = '30' } = req.query;\n    const dateRangeStr = `${dateRange} days`;\n    const clientId = req.user.clientId;\n    \n    const properties = await ClientPortalQueries.getClientProperties(clientId);\n    \n    // Get incident stats for each property\n    const propertiesWithStats = await Promise.all(properties.map(async (property) => {\n      const [stats] = await ClientPortalQueries.sequelize.query(`\n        SELECT \n          COUNT(i.id) as \"incidentCount\",\n          COUNT(i.id) FILTER (WHERE i.severity = 'critical') as \"criticalCount\",\n          COUNT(i.id) FILTER (WHERE i.severity = 'high') as \"highCount\",\n          COUNT(i.id) FILTER (WHERE i.status = 'resolved') as \"resolvedCount\",\n          COUNT(i.id) FILTER (WHERE i.\"incidentDate\" >= CURRENT_DATE - INTERVAL '7 days') as \"recentCount\",\n          COALESCE(ROUND(AVG(i.\"aiConfidence\"), 2), 0) as \"avgConfidence\"\n        FROM \"Incidents\" i\n        WHERE i.\"propertyId\" = :propertyId \n          AND i.\"incidentDate\" >= NOW() - INTERVAL :dateRange\n      `, {\n        replacements: { propertyId: property.id, dateRange: dateRangeStr },\n        type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n      });\n      \n      const incidentCount = parseInt(stats[0].incidentCount);\n      const resolvedCount = parseInt(stats[0].resolvedCount);\n      \n      return {\n        id: property.id,\n        name: property.name,\n        address: property.address,\n        propertyType: property.propertyType,\n        stats: {\n          incidentCount: incidentCount,\n          criticalCount: parseInt(stats[0].criticalCount),\n          highCount: parseInt(stats[0].highCount),\n          resolvedCount: resolvedCount,\n          recentCount: parseInt(stats[0].recentCount),\n          avgConfidence: parseFloat(stats[0].avgConfidence),\n          resolutionRate: incidentCount > 0 ? Math.round((resolvedCount / incidentCount) * 100) : 0\n        }\n      };\n    }));\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        dateRange: parseInt(dateRange),\n        properties: propertiesWithStats.sort((a, b) => b.stats.incidentCount - a.stats.incidentCount)\n      }\n    });\n    \n  } catch (error) {\n    console.error('Properties dashboard error:', error);\n    res.status(500).json({\n      error: 'Properties service error',\n      code: 'PROPERTIES_ERROR',\n      message: 'Unable to load properties data'\n    });\n  }\n});\n\nexport default router;