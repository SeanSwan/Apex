// backend/routes/client/v1/auth.mjs\n/**\n * Client Portal Authentication Routes\n * ==================================\n * Handles authentication for the Aegis Client Portal\n * Provides secure login, logout, and session management\n */\n\nimport express from 'express';\nimport bcrypt from 'bcrypt';\nimport rateLimit from 'express-rate-limit';\nimport { ClientPortalQueries } from '../../../database.mjs';\nimport { \n  createClientPortalSession,\n  authenticateClientSession,\n  logClientActivity \n} from '../../../middleware/clientAuth.mjs';\n\nconst router = express.Router();\n\n// Rate limiting for login attempts (5 attempts per 15 minutes)\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  message: {\n    error: 'Too many login attempts',\n    code: 'RATE_LIMIT_EXCEEDED',\n    message: 'Too many login attempts from this IP. Please try again in 15 minutes.',\n    retryAfter: 15 * 60\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Rate limiting for general auth endpoints (20 requests per 5 minutes)\nconst authLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 20,\n  message: {\n    error: 'Rate limit exceeded',\n    code: 'RATE_LIMIT_EXCEEDED', \n    message: 'Too many requests. Please try again in a few minutes.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n/**\n * @route   POST /api/client/v1/auth/login\n * @desc    Authenticate client user and create session\n * @access  Public (Rate Limited)\n */\nrouter.post('/login', loginLimiter, logClientActivity('login_attempt', 'auth'), async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Validate input\n    if (!email || !password) {\n      return res.status(400).json({\n        error: 'Missing credentials',\n        code: 'MISSING_CREDENTIALS',\n        message: 'Email and password are required'\n      });\n    }\n    \n    // Find user in database\n    const user = await ClientPortalQueries.authenticateClientUser(email.toLowerCase().trim());\n    \n    if (!user) {\n      // Log failed login attempt\n      await ClientPortalQueries.logClientPortalActivity(\n        null,\n        null,\n        'login_failed',\n        'auth',\n        null,\n        { reason: 'user_not_found', email: email.toLowerCase().trim() },\n        req.ip,\n        req.headers['user-agent'],\n        null\n      ).catch(err => console.error('Audit log error:', err));\n      \n      return res.status(401).json({\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS',\n        message: 'Email or password is incorrect'\n      });\n    }\n    \n    // Verify password\n    const passwordMatch = await bcrypt.compare(password, user.password);\n    \n    if (!passwordMatch) {\n      // Log failed login attempt\n      await ClientPortalQueries.logClientPortalActivity(\n        user.id,\n        user.clientId,\n        'login_failed',\n        'auth', \n        null,\n        { reason: 'invalid_password', email: user.email },\n        req.ip,\n        req.headers['user-agent'],\n        null\n      ).catch(err => console.error('Audit log error:', err));\n      \n      return res.status(401).json({\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS',\n        message: 'Email or password is incorrect'\n      });\n    }\n    \n    // Create session and tokens\n    const sessionData = await createClientPortalSession(user, req);\n    \n    // Set secure HTTP-only cookie for session token\n    res.cookie('client_session_token', sessionData.sessionToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      maxAge: 2 * 60 * 60 * 1000, // 2 hours\n      path: '/'\n    });\n    \n    // Return session info (without sensitive data)\n    res.status(200).json({\n      success: true,\n      message: 'Login successful',\n      data: {\n        user: sessionData.user,\n        accessToken: sessionData.accessToken,\n        expiresAt: sessionData.expiresAt,\n        permissions: sessionData.user.permissions\n      }\n    });\n    \n  } catch (error) {\n    console.error('Client login error:', error);\n    \n    // Log system error\n    await ClientPortalQueries.logClientPortalActivity(\n      null,\n      null,\n      'login_error',\n      'auth',\n      null,\n      { error: error.message },\n      req.ip,\n      req.headers['user-agent'],\n      null\n    ).catch(err => console.error('Audit log error:', err));\n    \n    res.status(500).json({\n      error: 'Login service error',\n      code: 'LOGIN_SERVICE_ERROR',\n      message: 'Unable to process login request. Please try again.'\n    });\n  }\n});\n\n/**\n * @route   POST /api/client/v1/auth/logout\n * @desc    Logout client user and invalidate session\n * @access  Private (Requires Authentication)\n */\nrouter.post('/logout', authLimiter, authenticateClientSession, logClientActivity('logout', 'auth'), async (req, res) => {\n  try {\n    const sessionToken = req.cookies?.client_session_token || \n      (req.headers.authorization && req.headers.authorization.replace('Bearer ', ''));\n    \n    if (sessionToken) {\n      // Invalidate session in database\n      await ClientPortalQueries.query(`\n        UPDATE \"ClientPortalSessions\" \n        SET \"isActive\" = false, \"updatedAt\" = NOW()\n        WHERE \"sessionToken\" = :sessionToken\n      `, {\n        replacements: { sessionToken }\n      });\n    }\n    \n    // Clear session cookie\n    res.clearCookie('client_session_token', {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      path: '/'\n    });\n    \n    res.status(200).json({\n      success: true,\n      message: 'Logout successful'\n    });\n    \n  } catch (error) {\n    console.error('Client logout error:', error);\n    \n    res.status(500).json({\n      error: 'Logout service error', \n      code: 'LOGOUT_SERVICE_ERROR',\n      message: 'Unable to complete logout. Please clear your browser cookies.'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/auth/profile\n * @desc    Get current user profile and permissions\n * @access  Private (Requires Authentication)\n */\nrouter.get('/profile', authLimiter, authenticateClientSession, logClientActivity('view_profile', 'user'), async (req, res) => {\n  try {\n    res.status(200).json({\n      success: true,\n      data: {\n        user: {\n          id: req.user.id,\n          firstName: req.user.firstName,\n          lastName: req.user.lastName,\n          email: req.user.email,\n          role: req.user.role,\n          clientId: req.user.clientId,\n          clientName: req.user.clientName,\n          permissions: req.user.permissions\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Profile fetch error:', error);\n    res.status(500).json({\n      error: 'Profile service error',\n      code: 'PROFILE_SERVICE_ERROR',\n      message: 'Unable to fetch user profile'\n    });\n  }\n});\n\n/**\n * @route   POST /api/client/v1/auth/refresh\n * @desc    Refresh access token using refresh token\n * @access  Public (Rate Limited)\n */\nrouter.post('/refresh', authLimiter, async (req, res) => {\n  try {\n    const { refreshToken } = req.body;\n    \n    if (!refreshToken) {\n      return res.status(400).json({\n        error: 'Missing refresh token',\n        code: 'MISSING_REFRESH_TOKEN',\n        message: 'Refresh token is required'\n      });\n    }\n    \n    // Validate refresh token\n    const [sessions] = await ClientPortalQueries.sequelize.query(`\n      SELECT s.\"userId\", s.\"expiresAt\", u.\"firstName\", u.\"lastName\", u.email, u.role, u.\"clientId\", u.\"clientPermissions\", c.name as \"clientName\"\n      FROM \"ClientPortalSessions\" s\n      JOIN \"Users\" u ON s.\"userId\" = u.id\n      LEFT JOIN \"Clients\" c ON u.\"clientId\" = c.id  \n      WHERE s.\"refreshToken\" = :refreshToken AND s.\"isActive\" = true AND s.\"expiresAt\" > NOW()\n    `, {\n      replacements: { refreshToken },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    if (!sessions[0]) {\n      return res.status(401).json({\n        error: 'Invalid refresh token',\n        code: 'INVALID_REFRESH_TOKEN',\n        message: 'Refresh token is invalid or expired'\n      });\n    }\n    \n    const userData = sessions[0];\n    \n    // Create new session\n    const sessionData = await createClientPortalSession(userData, req);\n    \n    res.status(200).json({\n      success: true,\n      message: 'Token refreshed successfully',\n      data: {\n        accessToken: sessionData.accessToken,\n        expiresAt: sessionData.expiresAt\n      }\n    });\n    \n  } catch (error) {\n    console.error('Token refresh error:', error);\n    res.status(500).json({\n      error: 'Token refresh service error',\n      code: 'REFRESH_SERVICE_ERROR',\n      message: 'Unable to refresh access token'\n    });\n  }\n});\n\n/**\n * @route   POST /api/client/v1/auth/change-password\n * @desc    Change user password\n * @access  Private (Requires Authentication)\n */\nrouter.post('/change-password', authLimiter, authenticateClientSession, logClientActivity('change_password', 'auth'), async (req, res) => {\n  try {\n    const { currentPassword, newPassword } = req.body;\n    \n    if (!currentPassword || !newPassword) {\n      return res.status(400).json({\n        error: 'Missing passwords',\n        code: 'MISSING_PASSWORDS',\n        message: 'Current password and new password are required'\n      });\n    }\n    \n    if (newPassword.length < 8) {\n      return res.status(400).json({\n        error: 'Password too short',\n        code: 'WEAK_PASSWORD',\n        message: 'New password must be at least 8 characters long'\n      });\n    }\n    \n    // Get current user data with password\n    const user = await ClientPortalQueries.authenticateClientUser(req.user.email);\n    \n    if (!user) {\n      return res.status(404).json({\n        error: 'User not found',\n        code: 'USER_NOT_FOUND'\n      });\n    }\n    \n    // Verify current password\n    const passwordMatch = await bcrypt.compare(currentPassword, user.password);\n    \n    if (!passwordMatch) {\n      return res.status(401).json({\n        error: 'Current password is incorrect',\n        code: 'INVALID_CURRENT_PASSWORD',\n        message: 'The current password you entered is incorrect'\n      });\n    }\n    \n    // Hash new password\n    const saltRounds = 12;\n    const hashedNewPassword = await bcrypt.hash(newPassword, saltRounds);\n    \n    // Update password in database\n    await ClientPortalQueries.sequelize.query(`\n      UPDATE \"Users\" \n      SET password = :hashedPassword, \"updatedAt\" = NOW()\n      WHERE id = :userId\n    `, {\n      replacements: { \n        hashedPassword: hashedNewPassword,\n        userId: req.user.id \n      }\n    });\n    \n    res.status(200).json({\n      success: true,\n      message: 'Password changed successfully'\n    });\n    \n  } catch (error) {\n    console.error('Password change error:', error);\n    res.status(500).json({\n      error: 'Password change service error',\n      code: 'PASSWORD_CHANGE_ERROR',\n      message: 'Unable to change password. Please try again.'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/auth/sessions\n * @desc    Get active sessions for current user\n * @access  Private (Requires Authentication)\n */\nrouter.get('/sessions', authLimiter, authenticateClientSession, logClientActivity('view_sessions', 'auth'), async (req, res) => {\n  try {\n    const [sessions] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        id, \"sessionToken\", \"ipAddress\", \"userAgent\", \"lastActivity\", \"createdAt\",\n        CASE WHEN \"sessionToken\" = :currentToken THEN true ELSE false END as \"isCurrent\"\n      FROM \"ClientPortalSessions\"\n      WHERE \"userId\" = :userId AND \"isActive\" = true AND \"expiresAt\" > NOW()\n      ORDER BY \"lastActivity\" DESC\n    `, {\n      replacements: { \n        userId: req.user.id,\n        currentToken: req.cookies?.client_session_token || req.headers.authorization?.replace('Bearer ', '')\n      },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        sessions: sessions.map(session => ({\n          id: session.id,\n          ipAddress: session.ipAddress,\n          userAgent: session.userAgent,\n          lastActivity: session.lastActivity,\n          createdAt: session.createdAt,\n          isCurrent: session.isCurrent\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Sessions fetch error:', error);\n    res.status(500).json({\n      error: 'Sessions service error',\n      code: 'SESSIONS_SERVICE_ERROR', \n      message: 'Unable to fetch active sessions'\n    });\n  }\n});\n\nexport default router;