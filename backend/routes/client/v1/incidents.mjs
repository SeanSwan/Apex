// backend/routes/client/v1/incidents.mjs\n/**\n * Client Portal Incidents API Routes\n * ==================================\n * Provides incident browsing, searching, and detailed view capabilities\n * All data is automatically scoped to the authenticated client\n */\n\nimport express from 'express';\nimport rateLimit from 'express-rate-limit';\nimport { ClientPortalQueries } from '../../../database.mjs';\nimport { \n  clientPortalAuth,\n  requireClientPermission,\n  logClientActivity \n} from '../../../middleware/clientAuth.mjs';\n\nconst router = express.Router();\n\n// Rate limiting for incidents APIs (200 requests per 5 minutes)\nconst incidentsLimiter = rateLimit({\n  windowMs: 5 * 60 * 1000, // 5 minutes\n  max: 200,\n  message: {\n    error: 'Rate limit exceeded',\n    code: 'INCIDENTS_RATE_LIMIT',\n    message: 'Too many incidents requests. Please wait a moment.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Apply authentication to all routes\nrouter.use(incidentsLimiter, ...clientPortalAuth, requireClientPermission('incidents'));\n\n/**\n * @route   GET /api/client/v1/incidents\n * @desc    Get paginated list of incidents with filtering and sorting\n * @access  Private (Client Portal Users with incidents permission)\n */\nrouter.get('/', logClientActivity('browse_incidents', 'incidents'), async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 25,\n      incidentType,\n      severity,\n      status,\n      propertyId,\n      dateFrom,\n      dateTo,\n      search,\n      sortBy = 'incidentDate',\n      sortOrder = 'desc'\n    } = req.query;\n    \n    const clientId = req.user.clientId;\n    const offset = (parseInt(page) - 1) * parseInt(limit);\n    \n    // Build filter object\n    const filters = {\n      limit: parseInt(limit),\n      offset: offset\n    };\n    \n    if (incidentType) filters.incidentType = incidentType;\n    if (severity) filters.severity = severity;\n    if (status) filters.status = status;\n    if (propertyId) filters.propertyId = parseInt(propertyId);\n    if (dateFrom) filters.dateFrom = dateFrom;\n    if (dateTo) filters.dateTo = dateTo;\n    \n    let whereClause = 'WHERE i.\"clientId\" = :clientId';\n    const replacements = { clientId };\n    \n    // Add search functionality\n    if (search && search.trim()) {\n      whereClause += ` AND (\n        i.\"incidentNumber\" ILIKE :search OR\n        i.description ILIKE :search OR\n        i.location ILIKE :search OR\n        i.\"reportedBy\" ILIKE :search OR\n        p.name ILIKE :search\n      )`;\n      replacements.search = `%${search.trim()}%`;\n    }\n    \n    // Add individual filters\n    if (filters.incidentType) {\n      whereClause += ' AND i.\"incidentType\" = :incidentType';\n      replacements.incidentType = filters.incidentType;\n    }\n    if (filters.severity) {\n      whereClause += ' AND i.severity = :severity';\n      replacements.severity = filters.severity;\n    }\n    if (filters.status) {\n      whereClause += ' AND i.status = :status';\n      replacements.status = filters.status;\n    }\n    if (filters.propertyId) {\n      whereClause += ' AND i.\"propertyId\" = :propertyId';\n      replacements.propertyId = filters.propertyId;\n    }\n    if (filters.dateFrom) {\n      whereClause += ' AND i.\"incidentDate\" >= :dateFrom';\n      replacements.dateFrom = filters.dateFrom;\n    }\n    if (filters.dateTo) {\n      whereClause += ' AND i.\"incidentDate\" <= :dateTo';\n      replacements.dateTo = filters.dateTo;\n    }\n    \n    // Validate and set sorting\n    const allowedSortFields = ['incidentDate', 'severity', 'status', 'incidentType', 'aiConfidence', 'incidentNumber'];\n    const sortField = allowedSortFields.includes(sortBy) ? sortBy : 'incidentDate';\n    const order = sortOrder.toLowerCase() === 'asc' ? 'ASC' : 'DESC';\n    \n    // Severity sorting requires custom ordering\n    let orderClause;\n    if (sortField === 'severity') {\n      orderClause = `ORDER BY \n        CASE i.severity \n          WHEN 'critical' THEN 1 \n          WHEN 'high' THEN 2 \n          WHEN 'medium' THEN 3 \n          WHEN 'low' THEN 4 \n          ELSE 5 \n        END ${order}`;\n    } else {\n      orderClause = `ORDER BY i.\"${sortField}\" ${order}`;\n    }\n    \n    // Get incidents with pagination\n    const [incidents] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        i.id, i.\"incidentNumber\", i.\"incidentType\", i.severity, i.status,\n        i.location, i.description, i.\"aiConfidence\", i.\"incidentDate\",\n        i.\"reportedBy\", i.\"reportedPhone\", i.\"resolvedAt\", i.\"resolutionNotes\",\n        p.name as \"propertyName\", p.address as \"propertyAddress\",\n        COUNT(e.id) as \"evidenceCount\",\n        u.\"firstName\" || ' ' || u.\"lastName\" as \"resolvedByName\"\n      FROM \"Incidents\" i\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      LEFT JOIN \"EvidenceFiles\" e ON i.id = e.\"incidentId\" AND e.\"isClientAccessible\" = true\n      LEFT JOIN \"Users\" u ON i.\"resolvedBy\" = u.id\n      ${whereClause}\n      GROUP BY i.id, p.name, p.address, u.\"firstName\", u.\"lastName\"\n      ${orderClause}\n      LIMIT :limit OFFSET :offset\n    `, {\n      replacements: { ...replacements, limit: parseInt(limit), offset },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get total count for pagination\n    const [totalCount] = await ClientPortalQueries.sequelize.query(`\n      SELECT COUNT(DISTINCT i.id) as total\n      FROM \"Incidents\" i\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      ${whereClause}\n    `, {\n      replacements,\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    const total = parseInt(totalCount[0].total);\n    const totalPages = Math.ceil(total / parseInt(limit));\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        incidents: incidents.map(incident => ({\n          id: incident.id,\n          incidentNumber: incident.incidentNumber,\n          incidentType: incident.incidentType,\n          severity: incident.severity,\n          status: incident.status,\n          location: incident.location,\n          description: incident.description.substring(0, 200) + (incident.description.length > 200 ? '...' : ''),\n          aiConfidence: parseFloat(incident.aiConfidence),\n          incidentDate: incident.incidentDate,\n          reportedBy: incident.reportedBy,\n          reportedPhone: incident.reportedPhone,\n          resolvedAt: incident.resolvedAt,\n          resolvedByName: incident.resolvedByName,\n          propertyName: incident.propertyName,\n          propertyAddress: incident.propertyAddress,\n          evidenceCount: parseInt(incident.evidenceCount)\n        })),\n        pagination: {\n          currentPage: parseInt(page),\n          totalPages: totalPages,\n          totalItems: total,\n          itemsPerPage: parseInt(limit),\n          hasNextPage: parseInt(page) < totalPages,\n          hasPrevPage: parseInt(page) > 1\n        },\n        filters: {\n          incidentType,\n          severity,\n          status,\n          propertyId: propertyId ? parseInt(propertyId) : null,\n          dateFrom,\n          dateTo,\n          search\n        },\n        sorting: {\n          sortBy: sortField,\n          sortOrder: order.toLowerCase()\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Incidents list error:', error);\n    res.status(500).json({\n      error: 'Incidents service error',\n      code: 'INCIDENTS_SERVICE_ERROR',\n      message: 'Unable to load incidents. Please try again.'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/incidents/:id\n * @desc    Get detailed information for a specific incident\n * @access  Private (Client Portal Users with incidents permission)\n */\nrouter.get('/:id', logClientActivity('view_incident_details', 'incident'), async (req, res) => {\n  try {\n    const incidentId = parseInt(req.params.id);\n    const clientId = req.user.clientId;\n    \n    if (!incidentId || isNaN(incidentId)) {\n      return res.status(400).json({\n        error: 'Invalid incident ID',\n        code: 'INVALID_INCIDENT_ID',\n        message: 'Incident ID must be a valid number'\n      });\n    }\n    \n    // Get incident details\n    const incident = await ClientPortalQueries.getClientIncidentDetails(clientId, incidentId);\n    \n    if (!incident) {\n      return res.status(404).json({\n        error: 'Incident not found',\n        code: 'INCIDENT_NOT_FOUND',\n        message: 'The requested incident was not found or you do not have access to it'\n      });\n    }\n    \n    // Get related evidence files\n    const evidence = await ClientPortalQueries.getClientEvidence(clientId, incidentId);\n    \n    // Get related call logs if any\n    const [callLogs] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        \"callId\", \"callerPhone\", \"callerName\", \"callDirection\", \"callStatus\",\n        \"duration\", \"aiHandled\", \"humanTakeover\", \"takeoverReason\", \n        \"callSummary\", \"callStarted\", \"callEnded\"\n      FROM \"CallLogs\"\n      WHERE \"incidentId\" = :incidentId AND \"clientId\" = :clientId\n      ORDER BY \"callStarted\" DESC\n    `, {\n      replacements: { incidentId, clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get response actions timeline\n    const responseActions = incident.responseActions ? JSON.parse(incident.responseActions) : [];\n    const notificationsSent = incident.notificationsSent ? JSON.parse(incident.notificationsSent) : [];\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        incident: {\n          id: incident.id,\n          incidentNumber: incident.incidentNumber,\n          incidentType: incident.incidentType,\n          severity: incident.severity,\n          status: incident.status,\n          location: incident.location,\n          description: incident.description,\n          aiConfidence: parseFloat(incident.aiConfidence),\n          incidentDate: incident.incidentDate,\n          reportedBy: incident.reportedBy,\n          reportedPhone: incident.reportedPhone,\n          resolvedAt: incident.resolvedAt,\n          resolvedByName: incident.resolvedByName,\n          resolutionNotes: incident.resolutionNotes,\n          propertyName: incident.propertyName,\n          propertyAddress: incident.propertyAddress,\n          responseActions: responseActions,\n          notificationsSent: notificationsSent,\n          createdAt: incident.createdAt,\n          updatedAt: incident.updatedAt\n        },\n        evidence: evidence.map(item => ({\n          id: item.id,\n          originalFileName: item.originalFileName,\n          fileType: item.fileType,\n          fileSize: item.fileSize,\n          thumbnailPath: item.thumbnailPath,\n          createdAt: item.createdAt\n        })),\n        callLogs: callLogs.map(call => ({\n          callId: call.callId,\n          callerPhone: call.callerPhone,\n          callerName: call.callerName,\n          callDirection: call.callDirection,\n          callStatus: call.callStatus,\n          duration: call.duration,\n          aiHandled: call.aiHandled,\n          humanTakeover: call.humanTakeover,\n          takeoverReason: call.takeoverReason,\n          callSummary: call.callSummary,\n          callStarted: call.callStarted,\n          callEnded: call.callEnded\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Incident details error:', error);\n    res.status(500).json({\n      error: 'Incident details service error',\n      code: 'INCIDENT_DETAILS_ERROR',\n      message: 'Unable to load incident details'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/incidents/filters/options\n * @desc    Get available filter options for incidents\n * @access  Private (Client Portal Users with incidents permission)\n */\nrouter.get('/filters/options', logClientActivity('get_incident_filters', 'incidents'), async (req, res) => {\n  try {\n    const clientId = req.user.clientId;\n    \n    // Get distinct incident types\n    const [incidentTypes] = await ClientPortalQueries.sequelize.query(`\n      SELECT DISTINCT \"incidentType\", COUNT(*) as count\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId\n      GROUP BY \"incidentType\"\n      ORDER BY count DESC, \"incidentType\" ASC\n    `, {\n      replacements: { clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get distinct severities\n    const [severities] = await ClientPortalQueries.sequelize.query(`\n      SELECT DISTINCT severity, COUNT(*) as count\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId AND severity IS NOT NULL\n      GROUP BY severity\n      ORDER BY \n        CASE severity \n          WHEN 'critical' THEN 1 \n          WHEN 'high' THEN 2 \n          WHEN 'medium' THEN 3 \n          WHEN 'low' THEN 4 \n          ELSE 5 \n        END\n    `, {\n      replacements: { clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get distinct statuses\n    const [statuses] = await ClientPortalQueries.sequelize.query(`\n      SELECT DISTINCT status, COUNT(*) as count\n      FROM \"Incidents\"\n      WHERE \"clientId\" = :clientId AND status IS NOT NULL\n      GROUP BY status\n      ORDER BY \n        CASE status\n          WHEN 'reported' THEN 1\n          WHEN 'investigating' THEN 2\n          WHEN 'resolved' THEN 3\n          WHEN 'closed' THEN 4\n          ELSE 5\n        END\n    `, {\n      replacements: { clientId },\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    // Get client properties\n    const properties = await ClientPortalQueries.getClientProperties(clientId);\n    \n    res.status(200).json({\n      success: true,\n      data: {\n        incidentTypes: incidentTypes.map(type => ({\n          value: type.incidentType,\n          label: type.incidentType.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n          count: parseInt(type.count)\n        })),\n        severities: severities.map(severity => ({\n          value: severity.severity,\n          label: severity.severity.charAt(0).toUpperCase() + severity.severity.slice(1),\n          count: parseInt(severity.count)\n        })),\n        statuses: statuses.map(status => ({\n          value: status.status,\n          label: status.status.charAt(0).toUpperCase() + status.status.slice(1),\n          count: parseInt(status.count)\n        })),\n        properties: properties.map(property => ({\n          value: property.id,\n          label: property.name,\n          address: property.address\n        }))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Incident filters error:', error);\n    res.status(500).json({\n      error: 'Filters service error',\n      code: 'FILTERS_ERROR',\n      message: 'Unable to load filter options'\n    });\n  }\n});\n\n/**\n * @route   GET /api/client/v1/incidents/export\n * @desc    Export incidents data as CSV\n * @access  Private (Client Portal Users with incidents permission)\n */\nrouter.get('/export', logClientActivity('export_incidents', 'incidents'), async (req, res) => {\n  try {\n    const {\n      incidentType,\n      severity,\n      status,\n      propertyId,\n      dateFrom,\n      dateTo,\n      format = 'csv'\n    } = req.query;\n    \n    const clientId = req.user.clientId;\n    \n    // Build filter conditions\n    let whereClause = 'WHERE i.\"clientId\" = :clientId';\n    const replacements = { clientId };\n    \n    if (incidentType) {\n      whereClause += ' AND i.\"incidentType\" = :incidentType';\n      replacements.incidentType = incidentType;\n    }\n    if (severity) {\n      whereClause += ' AND i.severity = :severity';\n      replacements.severity = severity;\n    }\n    if (status) {\n      whereClause += ' AND i.status = :status';\n      replacements.status = status;\n    }\n    if (propertyId) {\n      whereClause += ' AND i.\"propertyId\" = :propertyId';\n      replacements.propertyId = parseInt(propertyId);\n    }\n    if (dateFrom) {\n      whereClause += ' AND i.\"incidentDate\" >= :dateFrom';\n      replacements.dateFrom = dateFrom;\n    }\n    if (dateTo) {\n      whereClause += ' AND i.\"incidentDate\" <= :dateTo';\n      replacements.dateTo = dateTo;\n    }\n    \n    // Get incidents for export\n    const [incidents] = await ClientPortalQueries.sequelize.query(`\n      SELECT \n        i.\"incidentNumber\", i.\"incidentType\", i.severity, i.status,\n        i.location, i.description, i.\"aiConfidence\", i.\"incidentDate\",\n        i.\"reportedBy\", i.\"reportedPhone\", i.\"resolvedAt\",\n        p.name as \"propertyName\", p.address as \"propertyAddress\",\n        u.\"firstName\" || ' ' || u.\"lastName\" as \"resolvedByName\"\n      FROM \"Incidents\" i\n      JOIN \"Properties\" p ON i.\"propertyId\" = p.id\n      LEFT JOIN \"Users\" u ON i.\"resolvedBy\" = u.id\n      ${whereClause}\n      ORDER BY i.\"incidentDate\" DESC\n      LIMIT 1000  -- Reasonable export limit\n    `, {\n      replacements,\n      type: ClientPortalQueries.sequelize.QueryTypes.SELECT\n    });\n    \n    if (format === 'csv') {\n      // Generate CSV content\n      const headers = [\n        'Incident Number', 'Type', 'Severity', 'Status', 'Location', 'Description',\n        'AI Confidence', 'Incident Date', 'Reported By', 'Reported Phone',\n        'Resolved At', 'Resolved By', 'Property Name', 'Property Address'\n      ];\n      \n      let csvContent = headers.join(',') + '\\n';\n      \n      incidents.forEach(incident => {\n        const row = [\n          `\"${incident.incidentNumber}\"`,\n          `\"${incident.incidentType}\"`,\n          `\"${incident.severity}\"`,\n          `\"${incident.status}\"`,\n          `\"${(incident.location || '').replace(/\"/g, '\"\"')}\"`,\n          `\"${(incident.description || '').replace(/\"/g, '\"\"').substring(0, 100)}\"`,\n          incident.aiConfidence || '',\n          `\"${incident.incidentDate}\"`,\n          `\"${incident.reportedBy || ''}\"`,\n          `\"${incident.reportedPhone || ''}\"`,\n          `\"${incident.resolvedAt || ''}\"`,\n          `\"${incident.resolvedByName || ''}\"`,\n          `\"${incident.propertyName}\"`,\n          `\"${incident.propertyAddress}\"`\n        ];\n        csvContent += row.join(',') + '\\n';\n      });\n      \n      res.setHeader('Content-Type', 'text/csv');\n      res.setHeader('Content-Disposition', `attachment; filename=\"incidents_export_${new Date().toISOString().split('T')[0]}.csv\"`);\n      res.status(200).send(csvContent);\n    } else {\n      // Return JSON format\n      res.status(200).json({\n        success: true,\n        data: {\n          incidents: incidents,\n          exportDate: new Date().toISOString(),\n          totalRecords: incidents.length\n        }\n      });\n    }\n    \n  } catch (error) {\n    console.error('Incidents export error:', error);\n    res.status(500).json({\n      error: 'Export service error',\n      code: 'EXPORT_ERROR',\n      message: 'Unable to export incidents data'\n    });\n  }\n});\n\nexport default router;