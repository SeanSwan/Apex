#!/usr/bin/env node\n/**\n * RULES CONFIGURATION SYSTEM - COMPREHENSIVE TEST SUITE\n * ====================================================\n * Tests all components of the Rules Configuration system:\n * - Database connectivity and table structure\n * - API endpoints functionality\n * - Zone and rule CRUD operations\n * - Configuration import/export\n * - WebSocket real-time updates\n * - System integration\n */\n\nimport { Pool } from 'pg';\nimport fetch from 'node-fetch';\nimport dotenv from 'dotenv';\nimport { fileURLToPath } from 'url';\nimport path from 'path';\n\n// Load environment variables\ndotenv.config();\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst pool = new Pool({\n  user: process.env.PG_USER,\n  host: process.env.PG_HOST,\n  database: process.env.PG_DB,\n  password: process.env.PG_PASSWORD,\n  port: Number(process.env.PG_PORT),\n});\n\nconst API_BASE_URL = process.env.API_URL || 'http://localhost:5000/api';\nconst RULES_CONFIG_URL = `${API_BASE_URL}/rules-config`;\n\nclass RulesConfigurationTester {\n  constructor() {\n    this.testResults = {\n      passed: 0,\n      failed: 0,\n      total: 0,\n      details: []\n    };\n    this.createdZones = [];\n    this.createdRules = [];\n  }\n\n  // ========================================\n  // TEST EXECUTION FRAMEWORK\n  // ========================================\n\n  async runTest(testName, testFunction) {\n    this.testResults.total++;\n    console.log(`\\n🧪 Running test: ${testName}`);\n    \n    try {\n      const startTime = Date.now();\n      await testFunction();\n      const duration = Date.now() - startTime;\n      \n      console.log(`✅ PASS: ${testName} (${duration}ms)`);\n      this.testResults.passed++;\n      this.testResults.details.push({ name: testName, status: 'PASS', duration });\n      \n    } catch (error) {\n      console.log(`❌ FAIL: ${testName}`);\n      console.log(`   Error: ${error.message}`);\n      this.testResults.failed++;\n      this.testResults.details.push({ name: testName, status: 'FAIL', error: error.message });\n    }\n  }\n\n  async runAllTests() {\n    console.log('🛡️ APEX AI RULES CONFIGURATION - COMPREHENSIVE TEST SUITE');\n    console.log('=' .repeat(70));\n    console.log('');\n\n    // Database Tests\n    await this.runTest('Database Connection', () => this.testDatabaseConnection());\n    await this.runTest('Database Tables Structure', () => this.testDatabaseTables());\n    \n    // API Tests\n    await this.runTest('API Server Health', () => this.testAPIHealth());\n    await this.runTest('Zones API - Create Zone', () => this.testCreateZone());\n    await this.runTest('Zones API - Get Zones', () => this.testGetZones());\n    await this.runTest('Zones API - Update Zone', () => this.testUpdateZone());\n    await this.runTest('Rules API - Create Rule', () => this.testCreateRule());\n    await this.runTest('Rules API - Get Rules', () => this.testGetRules());\n    await this.runTest('Rules API - Update Rule', () => this.testUpdateRule());\n    await this.runTest('Rules API - Test Rule', () => this.testRuleExecution());\n    \n    // Configuration Tests\n    await this.runTest('Configuration Export', () => this.testConfigurationExport());\n    await this.runTest('Configuration Import', () => this.testConfigurationImport());\n    await this.runTest('System Status', () => this.testSystemStatus());\n    \n    // Cleanup Tests\n    await this.runTest('Cleanup Created Rules', () => this.testCleanupRules());\n    await this.runTest('Cleanup Created Zones', () => this.testCleanupZones());\n    \n    // Generate report\n    this.generateTestReport();\n  }\n\n  // ========================================\n  // DATABASE TESTS\n  // ========================================\n\n  async testDatabaseConnection() {\n    const client = await pool.connect();\n    const result = await client.query('SELECT NOW() as current_time, version() as version');\n    client.release();\n    \n    if (!result.rows[0]) {\n      throw new Error('No response from database');\n    }\n    \n    console.log(`   Database time: ${result.rows[0].current_time}`);\n  }\n\n  async testDatabaseTables() {\n    const client = await pool.connect();\n    \n    try {\n      // Check if all required tables exist\n      const tables = ['geofencing_zones', 'security_rules', 'rule_execution_log'];\n      \n      for (const table of tables) {\n        const result = await client.query(\n          `SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = $1)`,\n          [table]\n        );\n        \n        if (!result.rows[0].exists) {\n          throw new Error(`Table '${table}' does not exist`);\n        }\n      }\n      \n      // Check table structures\n      const zonesColumns = await client.query(\n        `SELECT column_name FROM information_schema.columns WHERE table_name = 'geofencing_zones'`\n      );\n      \n      const requiredZoneColumns = ['zone_id', 'name', 'polygon_points', 'zone_type', 'is_active'];\n      const existingColumns = zonesColumns.rows.map(row => row.column_name);\n      \n      for (const column of requiredZoneColumns) {\n        if (!existingColumns.includes(column)) {\n          throw new Error(`Required column '${column}' missing from geofencing_zones table`);\n        }\n      }\n      \n      console.log(`   Tables verified: ${tables.join(', ')}`);\n      console.log(`   Zones table columns: ${existingColumns.length}`);\n      \n    } finally {\n      client.release();\n    }\n  }\n\n  // ========================================\n  // API TESTS\n  // ========================================\n\n  async testAPIHealth() {\n    const response = await fetch(`${API_BASE_URL}/health`);\n    \n    if (!response.ok) {\n      throw new Error(`API health check failed: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data.status !== 'online') {\n      throw new Error(`API status is not online: ${data.status}`);\n    }\n    \n    console.log(`   API version: ${data.version}`);\n    console.log(`   Features: ${Object.keys(data.features || {}).length}`);\n  }\n\n  async testCreateZone() {\n    const testZone = {\n      zone_id: `test_zone_${Date.now()}`,\n      name: 'Test Zone for API Testing',\n      polygon_points: [[0.2, 0.2], [0.8, 0.2], [0.8, 0.8], [0.2, 0.8]],\n      zone_type: 'monitored',\n      coordinate_system: 'normalized',\n      camera_id: 'CAM-TEST-01',\n      is_active: true,\n      confidence_threshold: 0.75,\n      description: 'Automated test zone'\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/zones`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(testZone)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Zone creation failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.zone) {\n      throw new Error('Zone creation response invalid');\n    }\n    \n    this.createdZones.push(data.zone.zone_id);\n    console.log(`   Created zone: ${data.zone.zone_id}`);\n  }\n\n  async testGetZones() {\n    const response = await fetch(`${RULES_CONFIG_URL}/zones`);\n    \n    if (!response.ok) {\n      throw new Error(`Get zones failed: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !Array.isArray(data.zones)) {\n      throw new Error('Get zones response invalid');\n    }\n    \n    console.log(`   Found ${data.zones.length} zones`);\n    \n    // Test filtering\n    const filteredResponse = await fetch(`${RULES_CONFIG_URL}/zones?zone_type=monitored`);\n    const filteredData = await filteredResponse.json();\n    \n    console.log(`   Filtered (monitored): ${filteredData.zones?.length || 0} zones`);\n  }\n\n  async testUpdateZone() {\n    if (this.createdZones.length === 0) {\n      throw new Error('No zones available for update test');\n    }\n    \n    const zoneId = this.createdZones[0];\n    const updateData = {\n      name: 'Updated Test Zone',\n      description: 'Updated by automated test',\n      is_active: false\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/zones/${zoneId}`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(updateData)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Zone update failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || data.zone.name !== updateData.name) {\n      throw new Error('Zone update verification failed');\n    }\n    \n    console.log(`   Updated zone: ${zoneId}`);\n  }\n\n  async testCreateRule() {\n    if (this.createdZones.length === 0) {\n      throw new Error('No zones available for rule creation');\n    }\n    \n    const testRule = {\n      rule_id: `test_rule_${Date.now()}`,\n      name: 'Test Rule for API Testing',\n      description: 'Automated test rule',\n      zone_ids: [this.createdZones[0]],\n      conditions: [{\n        condition_id: 'test_condition_1',\n        condition_type: 'OBJECT_PRESENCE',\n        parameters: { min_objects: 1, max_objects: 5 },\n        operator: 'and',\n        weight: 1.0\n      }],\n      actions: ['alert', 'record'],\n      is_active: true,\n      priority: 7,\n      confidence_threshold: 0.8,\n      cooldown_period: 30,\n      rule_type: 'detection'\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/rules`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(testRule)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Rule creation failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.rule) {\n      throw new Error('Rule creation response invalid');\n    }\n    \n    this.createdRules.push(data.rule.rule_id);\n    console.log(`   Created rule: ${data.rule.rule_id}`);\n  }\n\n  async testGetRules() {\n    const response = await fetch(`${RULES_CONFIG_URL}/rules`);\n    \n    if (!response.ok) {\n      throw new Error(`Get rules failed: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !Array.isArray(data.rules)) {\n      throw new Error('Get rules response invalid');\n    }\n    \n    console.log(`   Found ${data.rules.length} rules`);\n  }\n\n  async testUpdateRule() {\n    if (this.createdRules.length === 0) {\n      throw new Error('No rules available for update test');\n    }\n    \n    const ruleId = this.createdRules[0];\n    const updateData = {\n      name: 'Updated Test Rule',\n      priority: 8,\n      is_active: false\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/rules/${ruleId}`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(updateData)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Rule update failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || data.rule.priority !== updateData.priority) {\n      throw new Error('Rule update verification failed');\n    }\n    \n    console.log(`   Updated rule: ${ruleId}`);\n  }\n\n  async testRuleExecution() {\n    if (this.createdRules.length === 0) {\n      throw new Error('No rules available for execution test');\n    }\n    \n    // Get the rule data first\n    const rulesResponse = await fetch(`${RULES_CONFIG_URL}/rules`);\n    const rulesData = await rulesResponse.json();\n    const testRule = rulesData.rules.find(r => r.rule_id === this.createdRules[0]);\n    \n    if (!testRule) {\n      throw new Error('Test rule not found for execution test');\n    }\n    \n    const threatData = {\n      threat_id: 'test_threat_001',\n      object_type: 'person',\n      confidence: 0.85,\n      location: { x: 0.5, y: 0.5 },\n      timestamp: new Date().toISOString(),\n      zone_id: this.createdZones[0]\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/test-rule`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ rule: testRule, threat_data: threatData })\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Rule test failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.test_result) {\n      throw new Error('Rule test response invalid');\n    }\n    \n    console.log(`   Rule test result: ${data.test_result.rule_triggered ? 'TRIGGERED' : 'NOT TRIGGERED'}`);\n  }\n\n  // ========================================\n  // CONFIGURATION TESTS\n  // ========================================\n\n  async testConfigurationExport() {\n    const response = await fetch(`${RULES_CONFIG_URL}/export`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ include_zones: true, include_rules: true })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Configuration export failed: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.export_data) {\n      throw new Error('Configuration export response invalid');\n    }\n    \n    console.log(`   Exported: ${data.zones_count} zones, ${data.rules_count} rules`);\n    \n    // Store for import test\n    this.exportedConfig = data.export_data;\n  }\n\n  async testConfigurationImport() {\n    if (!this.exportedConfig) {\n      throw new Error('No exported configuration available for import test');\n    }\n    \n    // Create a minimal test configuration\n    const testConfig = {\n      export_timestamp: new Date().toISOString(),\n      export_version: '1.0',\n      zones: [{\n        zone_id: `import_test_zone_${Date.now()}`,\n        name: 'Import Test Zone',\n        polygon_points: [[0.1, 0.1], [0.9, 0.1], [0.9, 0.9], [0.1, 0.9]],\n        zone_type: 'monitored',\n        coordinate_system: 'normalized',\n        camera_id: 'CAM-TEST-01',\n        is_active: true,\n        confidence_threshold: 0.75,\n        description: 'Test zone for import functionality'\n      }],\n      rules: []\n    };\n    \n    const response = await fetch(`${RULES_CONFIG_URL}/import`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ import_data: testConfig, merge_mode: 'merge' })\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`Configuration import failed: ${error.error || response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.import_results) {\n      throw new Error('Configuration import response invalid');\n    }\n    \n    console.log(`   Imported: ${data.import_results.zones_imported} zones, ${data.import_results.rules_imported} rules`);\n    \n    // Add imported zone to cleanup list\n    if (data.import_results.zones_imported > 0) {\n      this.createdZones.push(testConfig.zones[0].zone_id);\n    }\n  }\n\n  async testSystemStatus() {\n    const response = await fetch(`${RULES_CONFIG_URL}/status`);\n    \n    if (!response.ok) {\n      throw new Error(`System status failed: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    if (!data.success || !data.status) {\n      throw new Error('System status response invalid');\n    }\n    \n    console.log(`   System status: ${data.status.system_status}`);\n    console.log(`   Total zones: ${data.status.statistics?.total_zones || 'N/A'}`);\n    console.log(`   Total rules: ${data.status.statistics?.total_rules || 'N/A'}`);\n  }\n\n  // ========================================\n  // CLEANUP TESTS\n  // ========================================\n\n  async testCleanupRules() {\n    let deletedCount = 0;\n    \n    for (const ruleId of this.createdRules) {\n      try {\n        const response = await fetch(`${RULES_CONFIG_URL}/rules/${ruleId}`, {\n          method: 'DELETE'\n        });\n        \n        if (response.ok) {\n          deletedCount++;\n        }\n      } catch (error) {\n        console.log(`   Warning: Failed to delete rule ${ruleId}: ${error.message}`);\n      }\n    }\n    \n    console.log(`   Cleaned up ${deletedCount} rules`);\n  }\n\n  async testCleanupZones() {\n    let deletedCount = 0;\n    \n    for (const zoneId of this.createdZones) {\n      try {\n        const response = await fetch(`${RULES_CONFIG_URL}/zones/${zoneId}`, {\n          method: 'DELETE'\n        });\n        \n        if (response.ok) {\n          deletedCount++;\n        }\n      } catch (error) {\n        console.log(`   Warning: Failed to delete zone ${zoneId}: ${error.message}`);\n      }\n    }\n    \n    console.log(`   Cleaned up ${deletedCount} zones`);\n  }\n\n  // ========================================\n  // REPORTING\n  // ========================================\n\n  generateTestReport() {\n    console.log('\\n' + '=' .repeat(70));\n    console.log('🎯 TEST EXECUTION SUMMARY');\n    console.log('=' .repeat(70));\n    \n    const successRate = ((this.testResults.passed / this.testResults.total) * 100).toFixed(1);\n    \n    console.log(`\\n📊 Overall Results:`);\n    console.log(`   Total Tests: ${this.testResults.total}`);\n    console.log(`   Passed: ${this.testResults.passed} ✅`);\n    console.log(`   Failed: ${this.testResults.failed} ❌`);\n    console.log(`   Success Rate: ${successRate}%`);\n    \n    if (this.testResults.failed > 0) {\n      console.log(`\\n❌ Failed Tests:`);\n      this.testResults.details\n        .filter(result => result.status === 'FAIL')\n        .forEach(result => {\n          console.log(`   • ${result.name}: ${result.error}`);\n        });\n    }\n    \n    console.log(`\\n✅ Passed Tests:`);\n    this.testResults.details\n      .filter(result => result.status === 'PASS')\n      .forEach(result => {\n        console.log(`   • ${result.name} (${result.duration}ms)`);\n      });\n    \n    console.log('\\n' + '=' .repeat(70));\n    \n    if (this.testResults.failed === 0) {\n      console.log('🎉 ALL TESTS PASSED! Rules Configuration system is ready to use.');\n    } else {\n      console.log(`⚠️  ${this.testResults.failed} test(s) failed. Please review and fix issues before deployment.`);\n    }\n    \n    console.log('=' .repeat(70));\n  }\n}\n\n// ========================================\n// MAIN EXECUTION\n// ========================================\n\nasync function main() {\n  const tester = new RulesConfigurationTester();\n  \n  try {\n    await tester.runAllTests();\n  } catch (error) {\n    console.error('\\n❌ Test suite execution failed:', error.message);\n    process.exit(1);\n  } finally {\n    await pool.end();\n  }\n}\n\n// Run the tests\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n\nexport { RulesConfigurationTester };