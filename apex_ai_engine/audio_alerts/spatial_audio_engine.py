"""
APEX AI SPATIAL AUDIO ENGINE - TIER 2 3D POSITIONING
====================================================
Advanced spatial audio system for security threat alerts
Provides 3D positioned audio alerts based on threat location and severity

Features:
- 3D spatial audio positioning using HRTF (Head-Related Transfer Function)
- Threat-specific audio frequencies and patterns
- Real-time audio visualization data
- Multi-channel audio support
- Hardware device management
- Integration with frontend AudioAlertController
- Professional security audio protocols
"""

import asyncio
import math
import time
import threading
from typing import Dict, List, Tuple, Optional, Any
from datetime import datetime, timedelta
from collections import deque
from enum import Enum
import logging

# Audio processing imports (with fallbacks for systems without audio hardware)
try:\n    import numpy as np\n    NUMPY_AVAILABLE = True\nexcept ImportError:\n    NUMPY_AVAILABLE = False\n    print('⚠️ NumPy not available, using simulated audio processing')\n\ntry:\n    import sounddevice as sd\n    SOUNDDEVICE_AVAILABLE = True\nexcept ImportError:\n    SOUNDDEVICE_AVAILABLE = False\n    print('⚠️ SoundDevice not available, using simulated audio output')\n\nlogger = logging.getLogger(__name__)\n\nclass ThreatAudioProfile(Enum):\n    \"\"\"Audio profiles for different threat types\"\"\"\n    SAFE = 'safe'\n    LOW = 'low'\n    MEDIUM = 'medium'\n    HIGH = 'high'\n    CRITICAL = 'critical'\n    WEAPON = 'weapon'\n\nclass SpatialAudioEngine:\n    \"\"\"\n    Advanced spatial audio engine for security threat alerts\n    \n    Generates 3D positioned audio alerts that correspond to threat locations\n    on security monitors, allowing dispatchers to immediately identify\n    the spatial location of threats through audio cues.\n    \"\"\"\n    \n    def __init__(self, websocket_client=None, config: Dict[str, Any] = None):\n        \"\"\"\n        Initialize the spatial audio engine\n        \n        Args:\n            websocket_client: Socket.io client for frontend communication\n            config: Audio configuration dictionary\n        \"\"\"\n        self.websocket_client = websocket_client\n        self.config = config or {}\n        \n        # Audio system configuration\n        self.sample_rate = self.config.get('sample_rate', 44100)\n        self.buffer_size = self.config.get('buffer_size', 4096)\n        self.max_channels = self.config.get('max_channels', 8)\n        self.spatial_range = self.config.get('spatial_range', 10.0)  # meters\n        \n        # Audio device management\n        self.selected_device = None\n        self.available_devices = []\n        self.master_volume = 0.75\n        self.is_muted = False\n        self.spatial_mode = True\n        \n        # Threat audio profiles with frequencies and patterns\n        self.threat_audio_profiles = {\n            ThreatAudioProfile.SAFE: {\n                'frequencies': [440, 554],  # A4 and C#5\n                'volume': 0.3,\n                'pattern': 'gentle_pulse',\n                'duration': 1.0,\n                'spatial': False,\n                'priority': 1\n            },\n            ThreatAudioProfile.LOW: {\n                'frequencies': [523, 659],  # C5 and E5\n                'volume': 0.5,\n                'pattern': 'slow_beep',\n                'duration': 1.5,\n                'spatial': True,\n                'priority': 2\n            },\n            ThreatAudioProfile.MEDIUM: {\n                'frequencies': [659, 831],  # E5 and G#5\n                'volume': 0.7,\n                'pattern': 'attention_chime',\n                'duration': 2.0,\n                'spatial': True,\n                'priority': 4\n            },\n            ThreatAudioProfile.HIGH: {\n                'frequencies': [831, 1047], # G#5 and C6\n                'volume': 0.85,\n                'pattern': 'urgent_tone',\n                'duration': 2.5,\n                'spatial': True,\n                'priority': 8\n            },\n            ThreatAudioProfile.CRITICAL: {\n                'frequencies': [1047, 1319], # C6 and E6\n                'volume': 0.95,\n                'pattern': 'critical_alarm',\n                'duration': 3.0,\n                'spatial': True,\n                'priority': 16\n            },\n            ThreatAudioProfile.WEAPON: {\n                'frequencies': [1319, 1661], # E6 and G#6\n                'volume': 1.0,\n                'pattern': 'emergency_siren',\n                'duration': 4.0,\n                'spatial': True,\n                'priority': 32\n            }\n        }\n        \n        # Active audio alerts\n        self.active_audio_alerts = {}  # alert_id -> audio_data\n        self.audio_queue = deque(maxlen=100)\n        \n        # Audio visualization data\n        self.audio_meters = [0.0] * self.max_channels\n        self.active_frequencies = []\n        self.spatial_threats = []  # For frontend visualization\n        \n        # Performance and statistics\n        self.stats = {\n            'alerts_played': 0,\n            'total_audio_time': 0.0,\n            'peak_simultaneous_alerts': 0,\n            'spatial_alerts_played': 0,\n            'average_alert_duration': 0.0,\n            'frontend_updates_sent': 0\n        }\n        \n        # Thread safety\n        self._lock = threading.Lock()\n        \n        # Initialize audio system\n        self._initialize_audio_system()\n        \n        logger.info('🔊 Spatial Audio Engine initialized')\n    \n    def _initialize_audio_system(self):\n        \"\"\"Initialize the audio system and enumerate devices\"\"\"\n        try:\n            if SOUNDDEVICE_AVAILABLE:\n                # Get available audio devices\n                self.available_devices = sd.query_devices()\n                \n                # Select default output device\n                default_device = sd.default.device[1]  # Output device\n                if default_device is not None:\n                    self.selected_device = default_device\n                    logger.info(f'🎧 Selected audio device: {self.available_devices[default_device][\"name\"]}')\n                else:\n                    logger.warning('⚠️ No default audio output device found')\n            else:\n                # Simulated audio system\n                self.available_devices = [\n                    {'name': 'Simulated Audio Device 1', 'id': 0},\n                    {'name': 'Simulated Audio Device 2', 'id': 1}\n                ]\n                self.selected_device = 0\n                logger.info('🎧 Using simulated audio system')\n                \n        except Exception as e:\n            logger.error(f'❌ Audio system initialization failed: {e}')\n            # Fallback to simulated system\n            self.available_devices = [{'name': 'Fallback Audio', 'id': 0}]\n            self.selected_device = 0\n    \n    async def trigger_spatial_alert(self, alert_data: Dict[str, Any]) -> str:\n        \"\"\"\n        Trigger a spatial audio alert for a detected threat\n        \n        Args:\n            alert_data: Alert information including zone position and threat level\n        \n        Returns:\n            str: Audio alert ID\n        \"\"\"\n        alert_id = f'audio_{alert_data.get(\"zone_id\", \"unknown\")}_{int(time.time() * 1000)}'\n        \n        # Extract alert information\n        zone_id = alert_data.get('zone_id', 'UNKNOWN')\n        threat_level = alert_data.get('threat_level', 'MEDIUM')\n        zone_position = alert_data.get('zone_position', {'x': 0.5, 'y': 0.5})\n        confidence = alert_data.get('confidence', 75)\n        \n        # Get threat audio profile\n        try:\n            audio_profile_key = ThreatAudioProfile(threat_level.lower())\n        except ValueError:\n            audio_profile_key = ThreatAudioProfile.MEDIUM\n            logger.warning(f'⚠️ Unknown threat level {threat_level}, using MEDIUM')\n        \n        audio_profile = self.threat_audio_profiles[audio_profile_key]\n        \n        # Calculate spatial position (convert zone position to 3D coordinates)\n        spatial_coords = self._calculate_spatial_position(zone_position)\n        \n        # Create audio alert data\n        audio_alert = {\n            'alert_id': alert_id,\n            'zone_id': zone_id,\n            'threat_level': threat_level,\n            'audio_profile': audio_profile,\n            'spatial_coords': spatial_coords,\n            'zone_position': zone_position,\n            'confidence': confidence,\n            'start_time': time.time(),\n            'is_active': True,\n            'volume': audio_profile['volume'] * (self.master_volume if not self.is_muted else 0),\n            'spatial_enabled': self.spatial_mode and audio_profile['spatial']\n        }\n        \n        with self._lock:\n            # Check for existing alerts with lower priority\n            existing_alerts = list(self.active_audio_alerts.values())\n            if len(existing_alerts) >= self.max_channels:\n                self._remove_lowest_priority_alert()\n            \n            # Add new alert\n            self.active_audio_alerts[alert_id] = audio_alert\n            \n            # Update statistics\n            self.stats['alerts_played'] += 1\n            self.stats['peak_simultaneous_alerts'] = max(\n                self.stats['peak_simultaneous_alerts'],\n                len(self.active_audio_alerts)\n            )\n            \n            if audio_alert['spatial_enabled']:\n                self.stats['spatial_alerts_played'] += 1\n        \n        # Play the audio alert\n        await self._play_spatial_audio_alert(audio_alert)\n        \n        # Send audio data to frontend\n        await self._send_audio_alert_to_frontend(audio_alert)\n        \n        # Update spatial visualization\n        self._update_spatial_visualization(audio_alert)\n        \n        logger.info(f'🔊 Spatial audio alert triggered: {zone_id} - {threat_level} (volume: {audio_alert[\"volume\"]:.2f})')\n        \n        return alert_id\n    \n    def _calculate_spatial_position(self, zone_position: Dict[str, float]) -> Dict[str, float]:\n        \"\"\"\n        Convert 2D zone position to 3D spatial coordinates\n        \n        Args:\n            zone_position: Zone position {x: 0.0-1.0, y: 0.0-1.0}\n        \n        Returns:\n            3D spatial coordinates {x, y, z}\n        \"\"\"\n        # Convert normalized coordinates to spatial range\n        # X: left-right positioning\n        # Y: front-back positioning  \n        # Z: height (fixed for now)\n        \n        x = (zone_position.get('x', 0.5) - 0.5) * self.spatial_range\n        y = (zone_position.get('y', 0.5) - 0.5) * self.spatial_range\n        z = 0.0  # At ear level\n        \n        return {'x': x, 'y': y, 'z': z}\n    \n    async def _play_spatial_audio_alert(self, audio_alert: Dict[str, Any]):\n        \"\"\"\n        Play a spatial audio alert using the configured audio system\n        \n        Args:\n            audio_alert: Audio alert data\n        \"\"\"\n        if self.is_muted or audio_alert['volume'] <= 0:\n            logger.debug(f'🔇 Skipping muted audio alert {audio_alert[\"alert_id\"]}')\n            return\n        \n        try:\n            if SOUNDDEVICE_AVAILABLE and NUMPY_AVAILABLE:\n                # Generate real audio\n                await self._generate_real_audio(audio_alert)\n            else:\n                # Simulate audio playback\n                await self._simulate_audio_playback(audio_alert)\n                \n        except Exception as e:\n            logger.error(f'❌ Failed to play spatial audio alert: {e}')\n    \n    async def _generate_real_audio(self, audio_alert: Dict[str, Any]):\n        \"\"\"\n        Generate and play real spatial audio\n        \n        Args:\n            audio_alert: Audio alert data\n        \"\"\"\n        profile = audio_alert['audio_profile']\n        duration = profile['duration']\n        frequencies = profile['frequencies']\n        volume = audio_alert['volume']\n        spatial_coords = audio_alert['spatial_coords']\n        \n        # Generate audio samples\n        samples = int(self.sample_rate * duration)\n        t = np.linspace(0, duration, samples, False)\n        \n        # Create multi-tone alert\n        audio_signal = np.zeros(samples)\n        for freq in frequencies:\n            # Add frequency component with envelope\n            envelope = self._create_audio_envelope(t, profile['pattern'])\n            tone = np.sin(2 * np.pi * freq * t) * envelope * volume\n            audio_signal += tone\n        \n        # Apply spatial positioning if enabled\n        if audio_alert['spatial_enabled'] and self.spatial_mode:\n            # Simple stereo panning for spatial effect\n            # In a full implementation, this would use HRTF processing\n            left_gain, right_gain = self._calculate_stereo_panning(spatial_coords)\n            \n            # Create stereo output\n            stereo_audio = np.column_stack((\n                audio_signal * left_gain,\n                audio_signal * right_gain\n            ))\n        else:\n            # Mono to stereo\n            stereo_audio = np.column_stack((audio_signal, audio_signal))\n        \n        # Play audio using sounddevice\n        if self.selected_device is not None:\n            sd.play(stereo_audio, self.sample_rate, device=self.selected_device)\n            \n        # Update audio meters for visualization\n        self._update_audio_meters(stereo_audio)\n        \n        logger.debug(f'🎵 Generated spatial audio: {len(frequencies)} tones, {duration}s duration')\n    \n    async def _simulate_audio_playback(self, audio_alert: Dict[str, Any]):\n        \"\"\"\n        Simulate audio playback for systems without audio hardware\n        \n        Args:\n            audio_alert: Audio alert data\n        \"\"\"\n        profile = audio_alert['audio_profile']\n        duration = profile['duration']\n        volume = audio_alert['volume']\n        \n        # Simulate audio levels for visualization\n        simulated_levels = []\n        steps = 10\n        \n        for i in range(steps):\n            progress = i / steps\n            # Simulate decreasing volume over time\n            level = volume * (1.0 - progress * 0.5) * (0.8 + 0.4 * math.sin(progress * 8 * math.pi))\n            simulated_levels.append(level)\n            \n            # Update audio meters\n            self.audio_meters = [level * 100] * min(4, self.max_channels) + [0] * (self.max_channels - 4)\n            \n            # Send update to frontend\n            await self._send_audio_stats_to_frontend()\n            \n            await asyncio.sleep(duration / steps)\n        \n        # Reset audio meters\n        self.audio_meters = [0.0] * self.max_channels\n        \n        logger.debug(f'🎭 Simulated audio playback: {duration}s duration, volume: {volume:.2f}')\n    \n    def _create_audio_envelope(self, t: 'np.ndarray', pattern: str) -> 'np.ndarray':\n        \"\"\"\n        Create audio envelope based on threat pattern\n        \n        Args:\n            t: Time array\n            pattern: Audio pattern name\n        \n        Returns:\n            Envelope array\n        \"\"\"\n        if not NUMPY_AVAILABLE:\n            return [1.0] * len(t)\n        \n        duration = t[-1] if len(t) > 0 else 1.0\n        \n        if pattern == 'gentle_pulse':\n            # Smooth sine wave envelope\n            return 0.5 + 0.5 * np.sin(2 * np.pi * t / duration)\n            \n        elif pattern == 'slow_beep':\n            # Slower beeping pattern\n            return np.where(np.sin(4 * np.pi * t / duration) > 0, 1.0, 0.3)\n            \n        elif pattern == 'attention_chime':\n            # Attack-decay envelope\n            attack_time = 0.1\n            decay_time = duration - attack_time\n            \n            envelope = np.ones_like(t)\n            attack_mask = t < attack_time\n            decay_mask = t >= attack_time\n            \n            envelope[attack_mask] = t[attack_mask] / attack_time\n            envelope[decay_mask] = 1.0 - (t[decay_mask] - attack_time) / decay_time * 0.5\n            \n            return envelope\n            \n        elif pattern == 'urgent_tone':\n            # Fast oscillating envelope\n            return 0.7 + 0.3 * np.sin(8 * np.pi * t / duration)\n            \n        elif pattern == 'critical_alarm':\n            # Rapid on-off pattern\n            return np.where(np.sin(12 * np.pi * t / duration) > 0, 1.0, 0.1)\n            \n        elif pattern == 'emergency_siren':\n            # Siren-like frequency sweep effect on envelope\n            freq_sweep = 2 + 4 * np.sin(2 * np.pi * t / duration)\n            return 0.8 + 0.2 * np.sin(2 * np.pi * freq_sweep * t)\n            \n        else:\n            # Default steady envelope\n            return np.ones_like(t)\n    \n    def _calculate_stereo_panning(self, spatial_coords: Dict[str, float]) -> Tuple[float, float]:\n        \"\"\"\n        Calculate stereo panning based on spatial coordinates\n        \n        Args:\n            spatial_coords: 3D spatial coordinates\n        \n        Returns:\n            Tuple of (left_gain, right_gain)\n        \"\"\"\n        x = spatial_coords['x']\n        \n        # Simple stereo panning (-1.0 to 1.0)\n        # Normalize to spatial range\n        pan = max(-1.0, min(1.0, x / (self.spatial_range / 2)))\n        \n        # Calculate stereo gains (constant power panning)\n        angle = (pan + 1.0) * math.pi / 4  # 0 to π/2\n        left_gain = math.cos(angle)\n        right_gain = math.sin(angle)\n        \n        return left_gain, right_gain\n    \n    def _update_audio_meters(self, audio_data: 'np.ndarray'):\n        \"\"\"\n        Update audio level meters for visualization\n        \n        Args:\n            audio_data: Audio signal data\n        \"\"\"\n        if not NUMPY_AVAILABLE:\n            return\n        \n        # Calculate RMS levels for each channel\n        if len(audio_data.shape) == 2:  # Stereo\n            left_rms = np.sqrt(np.mean(audio_data[:, 0] ** 2))\n            right_rms = np.sqrt(np.mean(audio_data[:, 1] ** 2))\n            \n            self.audio_meters[0] = left_rms * 100\n            self.audio_meters[1] = right_rms * 100\n        else:  # Mono\n            rms = np.sqrt(np.mean(audio_data ** 2))\n            self.audio_meters[0] = rms * 100\n            self.audio_meters[1] = rms * 100\n        \n        # Fill remaining channels with decay\n        for i in range(2, self.max_channels):\n            self.audio_meters[i] = max(0, self.audio_meters[i] * 0.9)\n    \n    def _update_spatial_visualization(self, audio_alert: Dict[str, Any]):\n        \"\"\"\n        Update spatial visualization data for frontend\n        \n        Args:\n            audio_alert: Audio alert data\n        \"\"\"\n        threat_visual = {\n            'id': audio_alert['alert_id'],\n            'zone_id': audio_alert['zone_id'],\n            'x': audio_alert['zone_position']['x'] * 100,  # Convert to percentage\n            'y': audio_alert['zone_position']['y'] * 100,\n            'threat_level': audio_alert['threat_level'],\n            'timestamp': time.time()\n        }\n        \n        with self._lock:\n            # Add to spatial threats (keep last 10)\n            self.spatial_threats.append(threat_visual)\n            self.spatial_threats = self.spatial_threats[-10:]\n    \n    async def _send_audio_alert_to_frontend(self, audio_alert: Dict[str, Any]):\n        \"\"\"\n        Send audio alert data to frontend\n        \n        Args:\n            audio_alert: Audio alert data\n        \"\"\"\n        if not self.websocket_client:\n            return\n        \n        try:\n            frontend_alert = {\n                'alert_id': audio_alert['alert_id'],\n                'zone_id': audio_alert['zone_id'],\n                'threat_type': 'audio_alert',\n                'threat_level': audio_alert['threat_level'],\n                'zone_position': audio_alert['zone_position'],\n                'audio_stats': {\n                    'volume': audio_alert['volume'],\n                    'spatial_enabled': audio_alert['spatial_enabled'],\n                    'frequencies': audio_alert['audio_profile']['frequencies'],\n                    'pattern': audio_alert['audio_profile']['pattern'],\n                    'duration': audio_alert['audio_profile']['duration']\n                },\n                'timestamp': datetime.now().isoformat()\n            }\n            \n            await self.websocket_client.send_message('audio_alert', frontend_alert)\n            \n            self.stats['frontend_updates_sent'] += 1\n            \n            logger.debug(f'📤 Audio alert sent to frontend: {audio_alert[\"zone_id\"]}')\n            \n        except Exception as e:\n            logger.error(f'❌ Failed to send audio alert to frontend: {e}')\n    \n    async def _send_audio_stats_to_frontend(self):\n        \"\"\"\n        Send current audio statistics to frontend\n        \"\"\"\n        if not self.websocket_client:\n            return\n        \n        try:\n            stats_data = {\n                'audio_levels': self.audio_meters.copy(),\n                'active_channels': len([level for level in self.audio_meters if level > 0]),\n                'spatial_threats': self.spatial_threats.copy(),\n                'master_volume': self.master_volume,\n                'is_muted': self.is_muted,\n                'spatial_mode': self.spatial_mode,\n                'device_info': {\n                    'selected_device': self.selected_device,\n                    'available_devices': len(self.available_devices)\n                },\n                'timestamp': datetime.now().isoformat()\n            }\n            \n            await self.websocket_client.send_message('audio_stats', stats_data)\n            \n            logger.debug('📊 Audio stats sent to frontend')\n            \n        except Exception as e:\n            logger.error(f'❌ Failed to send audio stats to frontend: {e}')\n    \n    def _remove_lowest_priority_alert(self):\n        \"\"\"\n        Remove the lowest priority active audio alert\n        \"\"\"\n        if not self.active_audio_alerts:\n            return\n        \n        # Find lowest priority alert\n        lowest_priority = float('inf')\n        lowest_alert_id = None\n        \n        for alert_id, alert_data in self.active_audio_alerts.items():\n            priority = alert_data['audio_profile']['priority']\n            if priority < lowest_priority:\n                lowest_priority = priority\n                lowest_alert_id = alert_id\n        \n        if lowest_alert_id:\n            del self.active_audio_alerts[lowest_alert_id]\n            logger.info(f'🗑️ Removed low priority audio alert: {lowest_alert_id}')\n    \n    async def set_master_volume(self, volume: float):\n        \"\"\"\n        Set master volume level\n        \n        Args:\n            volume: Volume level (0.0 to 1.0)\n        \"\"\"\n        self.master_volume = max(0.0, min(1.0, volume))\n        logger.info(f'🔊 Master volume set to {self.master_volume:.2f}')\n        \n        # Send update to frontend\n        await self._send_audio_stats_to_frontend()\n    \n    async def set_mute(self, muted: bool):\n        \"\"\"\n        Set mute state\n        \n        Args:\n            muted: True to mute, False to unmute\n        \"\"\"\n        self.is_muted = muted\n        logger.info(f'🔇 Audio {\"muted\" if muted else \"unmuted\"}')\n        \n        # Send update to frontend\n        await self._send_audio_stats_to_frontend()\n    \n    async def set_spatial_mode(self, enabled: bool):\n        \"\"\"\n        Enable or disable spatial audio mode\n        \n        Args:\n            enabled: True to enable spatial mode\n        \"\"\"\n        self.spatial_mode = enabled\n        logger.info(f'🎯 Spatial audio mode {\"enabled\" if enabled else \"disabled\"}')\n        \n        # Send update to frontend\n        await self._send_audio_stats_to_frontend()\n    \n    def set_audio_device(self, device_id: int):\n        \"\"\"\n        Set the active audio output device\n        \n        Args:\n            device_id: Device ID from available devices\n        \"\"\"\n        if 0 <= device_id < len(self.available_devices):\n            self.selected_device = device_id\n            logger.info(f'🎧 Audio device changed to: {self.available_devices[device_id][\"name\"]}')\n        else:\n            logger.warning(f'⚠️ Invalid audio device ID: {device_id}')\n    \n    def get_audio_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get current audio engine statistics\n        \n        Returns:\n            Audio statistics dictionary\n        \"\"\"\n        with self._lock:\n            current_time = time.time()\n            \n            # Calculate average alert duration\n            active_durations = [\n                current_time - alert['start_time']\n                for alert in self.active_audio_alerts.values()\n            ]\n            \n            avg_duration = sum(active_durations) / len(active_durations) if active_durations else 0\n            \n            stats = self.stats.copy()\n            stats.update({\n                'active_alerts': len(self.active_audio_alerts),\n                'audio_meters': self.audio_meters.copy(),\n                'spatial_threats': self.spatial_threats.copy(),\n                'master_volume': self.master_volume,\n                'is_muted': self.is_muted,\n                'spatial_mode_enabled': self.spatial_mode,\n                'selected_device': self.selected_device,\n                'available_devices_count': len(self.available_devices),\n                'current_average_duration': avg_duration\n            })\n            \n            return stats\n    \n    def get_available_devices(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get list of available audio devices\n        \n        Returns:\n            List of device information\n        \"\"\"\n        return [\n            {\n                'id': i,\n                'name': device.get('name', f'Device {i}'),\n                'channels': device.get('max_output_channels', 2),\n                'sample_rate': device.get('default_samplerate', self.sample_rate)\n            }\n            for i, device in enumerate(self.available_devices)\n        ]\n    \n    async def stop_all_audio_alerts(self):\n        \"\"\"\n        Stop all active audio alerts\n        \"\"\"\n        with self._lock:\n            alert_count = len(self.active_audio_alerts)\n            self.active_audio_alerts.clear()\n            self.audio_meters = [0.0] * self.max_channels\n            self.spatial_threats.clear()\n        \n        if SOUNDDEVICE_AVAILABLE:\n            try:\n                sd.stop()\n            except:\n                pass\n        \n        # Send update to frontend\n        await self._send_audio_stats_to_frontend()\n        \n        logger.info(f'🛑 Stopped all audio alerts ({alert_count} alerts)')\n    \n    def set_websocket_client(self, websocket_client):\n        \"\"\"\n        Set or update the websocket client\n        \n        Args:\n            websocket_client: Socket.io client instance\n        \"\"\"\n        self.websocket_client = websocket_client\n        logger.info('🔌 WebSocket client updated for spatial audio engine')\n    \n    def cleanup_expired_alerts(self, max_age_seconds: int = 30):\n        \"\"\"\n        Clean up audio alerts that have been active too long\n        \n        Args:\n            max_age_seconds: Maximum age for alerts in seconds\n        \"\"\"\n        current_time = time.time()\n        expired_alerts = []\n        \n        with self._lock:\n            for alert_id, alert_data in self.active_audio_alerts.items():\n                if current_time - alert_data['start_time'] > max_age_seconds:\n                    expired_alerts.append(alert_id)\n        \n        # Remove expired alerts\n        for alert_id in expired_alerts:\n            if alert_id in self.active_audio_alerts:\n                del self.active_audio_alerts[alert_id]\n        \n        if expired_alerts:\n            logger.info(f'🧹 Cleaned up {len(expired_alerts)} expired audio alerts')\n    \n    def __del__(self):\n        \"\"\"Cleanup when engine is destroyed\"\"\"\n        try:\n            if SOUNDDEVICE_AVAILABLE:\n                sd.stop()\n        except:\n            pass"