"""
APEX AI ENHANCED SPATIAL AUDIO ENGINE - TIER 2 INTEGRATION
==========================================================
Enhanced spatial audio engine with Socket.io integration for frontend components
Connects backend audio processing with frontend AudioAlertController system

Features:
- Real-time Socket.io communication with frontend AudioAlertController
- Enhanced 3D spatial audio with frontend visualization
- Professional audio statistics and monitoring
- Multi-device management and configuration
- Integration with TIER 2 visual alert system
- Performance-optimized for real-time dispatch operations
"""

import asyncio
import json
import time
import threading
from typing import Dict, List, Tuple, Optional, Any, Callable
from datetime import datetime, timedelta
import logging

# Import the base spatial audio engine
from .spatial_audio_engine import SpatialAudioEngine, SpatialPosition, AudioChannel, ThreatLevel

logger = logging.getLogger(__name__)

class EnhancedSpatialAudioEngine(SpatialAudioEngine):
    \"\"\"
    Enhanced Spatial Audio Engine with TIER 2 frontend integration
    
    Extends the base spatial audio engine with Socket.io communication
    and integration with the professional frontend AudioAlertController.
    \"\"\"
    
    def __init__(self, websocket_client=None, sample_rate: int = 44100, 
                 buffer_size: int = 1024, channels: int = 8, config: Dict[str, Any] = None):
        \"\"\"
        Initialize enhanced spatial audio engine
        
        Args:
            websocket_client: Enhanced WebSocket client for frontend communication
            sample_rate: Audio sample rate in Hz
            buffer_size: Audio buffer size in samples
            channels: Number of audio output channels
            config: Configuration dictionary
        \"\"\"
        super().__init__(sample_rate, buffer_size, channels)
        
        # Frontend integration
        self.websocket_client = websocket_client
        self.frontend_integration_enabled = websocket_client is not None
        self.config = config or {}
        
        # Enhanced audio statistics for frontend
        self.enhanced_stats = {
            'audio_levels': [0.0] * 8,  # 8-channel audio levels for visualization
            'active_channels': 0,
            'spatial_threats': [],  # Active spatial threats for visualization
            'device_configuration': {},
            'performance_metrics': {
                'latency_ms': 0.0,
                'cpu_usage_percent': 0.0,
                'buffer_health': 100.0\n            },\n            'last_stats_update': time.time()\n        }\n        \n        # Frontend threat positioning for visualization\n        self.frontend_threat_positions = {}\n        \n        # Audio device management\n        self.available_devices = []\n        self.selected_device_id = None\n        self.device_capabilities = {}\n        \n        # Background task management\n        self.stats_sender_task = None\n        self.device_monitor_task = None\n        self.is_frontend_running = False\n        \n        # Audio level monitoring for visualization\n        self.level_monitor_enabled = True\n        self.level_update_interval = 0.1  # 100ms updates\n        self.last_level_update = 0\n        \n        # Spatial visualization data\n        self.spatial_visualization_data = {\n            'dispatcher_position': SpatialPosition(0.0, 0.0, 0.0),\n            'room_dimensions': {'width': 10.0, 'height': 10.0, 'depth': 3.0},\n            'threat_indicators': {}\n        }\n        \n        # Enhanced threat type to audio mapping\n        self.enhanced_threat_audio_config = {\n            'WEAPON': {\n                'frequency_range': (800, 1200),\n                'pattern': 'urgent_strobe',\n                'volume_multiplier': 1.0,\n                'spatial_emphasis': True\n            },\n            'HIGH': {\n                'frequency_range': (500, 800),\n                'pattern': 'fast_pulse',\n                'volume_multiplier': 0.85,\n                'spatial_emphasis': True\n            },\n            'CRITICAL': {\n                'frequency_range': (600, 1000),\n                'pattern': 'critical_alarm',\n                'volume_multiplier': 0.95,\n                'spatial_emphasis': True\n            },\n            'MEDIUM': {\n                'frequency_range': (400, 600),\n                'pattern': 'steady_tone',\n                'volume_multiplier': 0.7,\n                'spatial_emphasis': False\n            },\n            'LOW': {\n                'frequency_range': (300, 500),\n                'pattern': 'soft_pulse',\n                'volume_multiplier': 0.5,\n                'spatial_emphasis': False\n            }\n        }\n        \n        logger.info(f\"üîä Enhanced Spatial Audio Engine initialized (Frontend: {'‚úÖ' if self.frontend_integration_enabled else '‚ùå'})\")\n    \n    async def start_frontend_integration(self):\n        \"\"\"Start frontend integration tasks\"\"\"\n        if not self.frontend_integration_enabled:\n            logger.warning(\"‚ö†Ô∏è Frontend integration not available - no WebSocket client provided\")\n            return\n        \n        self.is_frontend_running = True\n        \n        # Enumerate audio devices\n        await self._enumerate_audio_devices()\n        \n        # Start background tasks\n        self.stats_sender_task = asyncio.create_task(self._send_audio_stats())\n        self.device_monitor_task = asyncio.create_task(self._monitor_audio_devices())\n        \n        logger.info(\"‚úÖ Enhanced audio frontend integration started\")\n    \n    async def stop_frontend_integration(self):\n        \"\"\"Stop frontend integration tasks\"\"\"\n        self.is_frontend_running = False\n        \n        if self.stats_sender_task:\n            self.stats_sender_task.cancel()\n        \n        if self.device_monitor_task:\n            self.device_monitor_task.cancel()\n        \n        logger.info(\"üõë Enhanced audio frontend integration stopped\")\n    \n    def play_enhanced_threat_alert(self, alert_data: Dict[str, Any]) -> str:\n        \"\"\"Play enhanced spatial audio alert with frontend integration\"\"\"\n        # Play the base alert\n        alert_id = super().play_threat_alert(alert_data)\n        \n        if not alert_id or not self.frontend_integration_enabled:\n            return alert_id\n        \n        # Enhanced processing for frontend\n        try:\n            self._prepare_frontend_audio_data(alert_id, alert_data)\n        except Exception as e:\n            logger.error(f\"‚ùå Error preparing frontend audio data: {e}\")\n        \n        return alert_id\n    \n    def _prepare_frontend_audio_data(self, alert_id: str, alert_data: Dict[str, Any]):\n        \"\"\"Prepare audio data for frontend visualization\"\"\"\n        threat_level = alert_data.get('threat_level', ThreatLevel.MEDIUM)\n        zone_id = alert_data.get('zone_id', 'UNKNOWN')\n        \n        # Map threat level to frontend format\n        frontend_threat_level = {\n            ThreatLevel.LOW: 'LOW',\n            ThreatLevel.MEDIUM: 'MEDIUM',\n            ThreatLevel.HIGH: 'HIGH',\n            ThreatLevel.CRITICAL: 'CRITICAL'\n        }.get(threat_level, 'MEDIUM')\n        \n        # Check for weapon detection\n        threat_type = alert_data.get('type', '').lower()\n        if threat_type in ['weapon', 'weapon_detected', 'gun', 'knife']:\n            frontend_threat_level = 'WEAPON'\n        \n        # Get spatial position\n        spatial_position = self.zone_positions.get(zone_id, SpatialPosition(0.0, 0.0, 0.0))\n        \n        # Calculate frontend position (normalize to 0-100%)\n        frontend_position = {\n            'x': (spatial_position.x + 1.0) * 50,  # Convert -1,1 to 0,100\n            'y': (spatial_position.y + 1.0) * 50   # Convert -1,1 to 0,100\n        }\n        \n        # Add to spatial visualization\n        threat_indicator = {\n            'id': alert_id,\n            'zone_id': zone_id,\n            'threat_level': frontend_threat_level,\n            'position': frontend_position,\n            'timestamp': time.time(),\n            'audio_config': self.enhanced_threat_audio_config.get(frontend_threat_level, {})\n        }\n        \n        self.enhanced_stats['spatial_threats'].append(threat_indicator)\n        \n        # Keep only recent threats (last 30 seconds)\n        current_time = time.time()\n        self.enhanced_stats['spatial_threats'] = [\n            threat for threat in self.enhanced_stats['spatial_threats']\n            if current_time - threat['timestamp'] < 30\n        ]\n        \n        logger.debug(f\"üéØ Added frontend audio visualization for {zone_id} at {frontend_position}\")\n    \n    async def _send_audio_stats(self):\n        \"\"\"Background task to send audio statistics to frontend\"\"\"\n        logger.info(\"üìä Started audio stats sender\")\n        \n        while self.is_frontend_running:\n            try:\n                await asyncio.sleep(0.2)  # 5 FPS update rate\n                \n                if self.websocket_client:\n                    # Update audio levels\n                    self._update_audio_levels()\n                    \n                    # Create enhanced stats for frontend\n                    frontend_stats = self._create_frontend_stats()\n                    \n                    # Send to AudioAlertController\n                    await self.websocket_client.send_message('audio_stats', frontend_stats)\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error sending audio stats: {e}\")\n                await asyncio.sleep(1)\n    \n    def _update_audio_levels(self):\n        \"\"\"Update real-time audio level visualization data\"\"\"\n        current_time = time.time()\n        \n        if current_time - self.last_level_update < self.level_update_interval:\n            return\n        \n        # Simulate audio levels based on active alerts\n        if self.active_alerts:\n            # Generate realistic audio level data\n            import random\n            import math\n            \n            base_levels = [20, 15, 10, 25, 18, 12, 8, 22]  # Base noise floor\n            \n            for i in range(8):\n                if self.active_alerts:\n                    # Add alert activity to levels\n                    alert_boost = random.uniform(30, 80) * len(self.active_alerts) / 4\n                    wave_factor = math.sin(current_time * 10 + i) * 15\n                    level = base_levels[i] + alert_boost + wave_factor\n                else:\n                    level = base_levels[i] + random.uniform(-5, 5)\n                \n                self.enhanced_stats['audio_levels'][i] = max(0, min(100, level))\n        else:\n            # Decay levels when no alerts\n            for i in range(8):\n                current_level = self.enhanced_stats['audio_levels'][i]\n                self.enhanced_stats['audio_levels'][i] = max(0, current_level * 0.95)\n        \n        self.enhanced_stats['active_channels'] = sum(1 for level in self.enhanced_stats['audio_levels'] if level > 10)\n        self.last_level_update = current_time\n    \n    def _create_frontend_stats(self) -> Dict[str, Any]:\n        \"\"\"Create frontend-compatible statistics\"\"\"\n        base_stats = super().get_audio_statistics()\n        \n        frontend_stats = {\n            'audio_levels': self.enhanced_stats['audio_levels'].copy(),\n            'active_channels': self.enhanced_stats['active_channels'],\n            'spatial_threats': self.enhanced_stats['spatial_threats'].copy(),\n            'device_info': {\n                'selected_device': self.selected_device_id,\n                'available_devices': len(self.available_devices),\n                'sample_rate': self.sample_rate,\n                'channels': self.channels,\n                'is_initialized': self.is_initialized,\n                'is_enabled': self.is_enabled\n            },\n            'performance': {\n                'latency_ms': self.enhanced_stats['performance_metrics']['latency_ms'],\n                'cpu_usage': self.enhanced_stats['performance_metrics']['cpu_usage_percent'],\n                'buffer_health': self.enhanced_stats['performance_metrics']['buffer_health'],\n                'active_alerts': len(self.active_alerts),\n                'alerts_played': base_stats['alerts_played']\n            },\n            'spatial_config': {\n                'room_dimensions': self.spatial_visualization_data['room_dimensions'],\n                'dispatcher_position': {\n                    'x': self.spatial_visualization_data['dispatcher_position'].x,\n                    'y': self.spatial_visualization_data['dispatcher_position'].y\n                },\n                'zone_count': len(self.zone_positions)\n            },\n            'timestamp': time.time()\n        }\n        \n        return frontend_stats\n    \n    async def _enumerate_audio_devices(self):\n        \"\"\"Enumerate available audio devices for frontend selection\"\"\"\n        if not self.pyaudio_instance:\n            return\n        \n        try:\n            device_count = self.pyaudio_instance.get_device_count()\n            self.available_devices = []\n            \n            for i in range(device_count):\n                try:\n                    device_info = self.pyaudio_instance.get_device_info_by_index(i)\n                    \n                    if device_info['maxOutputChannels'] > 0:\n                        device_data = {\n                            'id': i,\n                            'name': device_info['name'],\n                            'channels': device_info['maxOutputChannels'],\n                            'sample_rate': device_info['defaultSampleRate'],\n                            'is_default': i == self.pyaudio_instance.get_default_output_device_info()['index']\n                        }\n                        \n                        self.available_devices.append(device_data)\n                        \n                        if device_data['is_default'] and not self.selected_device_id:\n                            self.selected_device_id = i\n                            \n                except Exception as e:\n                    logger.debug(f\"Error enumerating device {i}: {e}\")\n                    continue\n            \n            logger.info(f\"üéß Enumerated {len(self.available_devices)} audio output devices\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error enumerating audio devices: {e}\")\n    \n    async def _monitor_audio_devices(self):\n        \"\"\"Monitor for audio device changes\"\"\"\n        logger.info(\"üéß Started audio device monitor\")\n        \n        while self.is_frontend_running:\n            try:\n                await asyncio.sleep(5)  # Check every 5 seconds\n                \n                # Re-enumerate devices to detect changes\n                old_device_count = len(self.available_devices)\n                await self._enumerate_audio_devices()\n                new_device_count = len(self.available_devices)\n                \n                if new_device_count != old_device_count:\n                    logger.info(f\"üéß Audio device configuration changed: {old_device_count} -> {new_device_count}\")\n                    \n                    if self.websocket_client:\n                        await self.websocket_client.send_message('audio_device_change', {\n                            'available_devices': self.available_devices,\n                            'selected_device': self.selected_device_id,\n                            'timestamp': time.time()\n                        })\n                \n            except Exception as e:\n                logger.error(f\"‚ùå Error monitoring audio devices: {e}\")\n                await asyncio.sleep(10)\n    \n    async def handle_frontend_audio_command(self, command: str, data: Dict[str, Any]):\n        \"\"\"Handle audio commands from frontend AudioAlertController\"\"\"\n        try:\n            if command == 'set_master_volume':\n                volume = data.get('volume', 0.5)\n                self.set_master_volume(volume)\n                \n            elif command == 'set_audio_enabled':\n                enabled = data.get('enabled', True)\n                self.set_enabled(enabled)\n                \n            elif command == 'select_audio_device':\n                device_id = data.get('device_id')\n                await self._select_audio_device(device_id)\n                \n            elif command == 'stop_all_audio':\n                self.stop_all_alerts()\n                \n            elif command == 'test_spatial_audio':\n                await self._test_spatial_audio(data)\n                \n            elif command == 'configure_spatial_layout':\n                await self._configure_spatial_layout(data)\n                \n            else:\n                logger.warning(f\"‚ö†Ô∏è Unknown audio command: {command}\")\n                \n        except Exception as e:\n            logger.error(f\"‚ùå Error handling audio command '{command}': {e}\")\n    \n    async def _select_audio_device(self, device_id: int):\n        \"\"\"Select a different audio output device\"\"\"\n        if device_id in [device['id'] for device in self.available_devices]:\n            self.selected_device_id = device_id\n            \n            # TODO: Reinitialize audio stream with new device\n            # This would require stopping current stream and creating new one\n            \n            logger.info(f\"üéß Selected audio device: {device_id}\")\n            \n            if self.websocket_client:\n                await self.websocket_client.send_message('audio_device_selected', {\n                    'device_id': device_id,\n                    'timestamp': time.time()\n                })\n        else:\n            logger.error(f\"‚ùå Invalid audio device ID: {device_id}\")\n    \n    async def _test_spatial_audio(self, test_data: Dict[str, Any]):\n        \"\"\"Test spatial audio with specific parameters\"\"\"\n        test_position = test_data.get('position', {'x': 50, 'y': 50})\n        test_threat_level = test_data.get('threat_level', 'MEDIUM')\n        \n        # Convert frontend position to spatial position\n        spatial_pos = SpatialPosition(\n            x=(test_position['x'] / 50.0) - 1.0,  # Convert 0-100 to -1,1\n            y=(test_position['y'] / 50.0) - 1.0   # Convert 0-100 to -1,1\n        )\n        \n        # Register temporary test zone\n        test_zone_id = 'SPATIAL_TEST_ZONE'\n        self.register_zone_position(test_zone_id, spatial_pos)\n        \n        # Play test alert\n        test_alert_data = {\n            'type': 'spatial_test',\n            'threat_level': getattr(ThreatLevel, test_threat_level, ThreatLevel.MEDIUM),\n            'zone_id': test_zone_id,\n            'confidence': 0.8\n        }\n        \n        alert_id = self.play_enhanced_threat_alert(test_alert_data)\n        \n        logger.info(f\"üéØ Spatial audio test played at position ({test_position['x']}, {test_position['y']})\")\n        \n        if self.websocket_client:\n            await self.websocket_client.send_message('spatial_audio_test_played', {\n                'alert_id': alert_id,\n                'position': test_position,\n                'threat_level': test_threat_level,\n                'timestamp': time.time()\n            })\n    \n    async def _configure_spatial_layout(self, layout_data: Dict[str, Any]):\n        \"\"\"Configure spatial audio layout from frontend\"\"\"\n        try:\n            room_dimensions = layout_data.get('room_dimensions', {})\n            if room_dimensions:\n                self.spatial_visualization_data['room_dimensions'].update(room_dimensions)\n            \n            dispatcher_position = layout_data.get('dispatcher_position', {})\n            if dispatcher_position:\n                self.spatial_visualization_data['dispatcher_position'] = SpatialPosition(\n                    x=dispatcher_position.get('x', 0.0),\n                    y=dispatcher_position.get('y', 0.0),\n                    z=dispatcher_position.get('z', 0.0)\n                )\n            \n            speaker_layout = layout_data.get('speaker_layout', {})\n            if speaker_layout:\n                # Convert frontend speaker positions to spatial positions\n                converted_layout = {}\n                for channel_name, position in speaker_layout.items():\n                    try:\n                        channel = AudioChannel(channel_name)\n                        spatial_pos = SpatialPosition(\n                            x=position.get('x', 0.0),\n                            y=position.get('y', 0.0),\n                            z=position.get('z', 0.0)\n                        )\n                        converted_layout[channel] = spatial_pos\n                    except ValueError:\n                        logger.warning(f\"‚ö†Ô∏è Invalid audio channel: {channel_name}\")\n                \n                if converted_layout:\n                    self.configure_speaker_layout(converted_layout)\n            \n            logger.info(\"üéØ Spatial audio layout configured from frontend\")\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error configuring spatial layout: {e}\")\n    \n    def get_enhanced_audio_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get enhanced audio statistics including frontend integration\"\"\"\n        base_stats = super().get_audio_statistics()\n        \n        enhanced_stats = {\n            **base_stats,\n            'frontend_integration': {\n                'enabled': self.frontend_integration_enabled,\n                'is_running': self.is_frontend_running,\n                'available_devices': len(self.available_devices),\n                'selected_device': self.selected_device_id\n            },\n            'spatial_visualization': self.spatial_visualization_data,\n            'enhanced_features': {\n                'threat_audio_configs': len(self.enhanced_threat_audio_config),\n                'active_spatial_threats': len(self.enhanced_stats['spatial_threats']),\n                'level_monitoring_enabled': self.level_monitor_enabled\n            },\n            'performance_metrics': self.enhanced_stats['performance_metrics'].copy()\n        }\n        \n        return enhanced_stats\n    \n    async def test_frontend_audio_integration(self) -> bool:\n        \"\"\"Test frontend audio integration\"\"\"\n        if not self.frontend_integration_enabled:\n            logger.warning(\"‚ö†Ô∏è Frontend audio integration not enabled\")\n            return False\n        \n        try:\n            # Send test audio stats\n            test_stats = {\n                'audio_levels': [50, 30, 20, 60, 40, 25, 15, 45],\n                'active_channels': 4,\n                'spatial_threats': [{\n                    'id': 'test_threat',\n                    'zone_id': 'TEST_ZONE',\n                    'threat_level': 'HIGH',\n                    'position': {'x': 75, 'y': 25},\n                    'timestamp': time.time()\n                }],\n                'device_info': {\n                    'is_initialized': True,\n                    'is_enabled': True,\n                    'sample_rate': self.sample_rate,\n                    'channels': self.channels\n                },\n                'test_mode': True\n            }\n            \n            await self.websocket_client.send_message('audio_stats', test_stats)\n            \n            logger.info(\"‚úÖ Frontend audio integration test completed successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Frontend audio integration test failed: {e}\")\n            return False"