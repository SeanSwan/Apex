"""
APEX AI TIER 2 ALERT INTEGRATION MODULE\n=====================================\nIntegration layer for visual and audio alert systems\nConnects threat detection to professional frontend alert components\n\nFeatures:\n- Unified alert triggering for visual and audio systems\n- Threat level escalation and coordination\n- Real-time frontend communication\n- Performance monitoring and statistics\n- Professional security alert protocols\n\"\"\"\n\nimport asyncio\nimport logging\nfrom typing import Dict, List, Optional, Any\nfrom datetime import datetime\nimport time\n\n# Import our enhanced alert engines\nfrom visual_alerts.enhanced_visual_alert_engine import EnhancedVisualAlertEngine, ThreatLevel\nfrom audio_alerts.spatial_audio_engine import SpatialAudioEngine, ThreatAudioProfile\n\n# Import multi-monitor threat correlation engine
from threat_correlation_engine import ThreatCorrelationEngine, ThreatCorrelationStatus

logger = logging.getLogger(__name__)\n\nclass Tier2AlertCoordinator:\n    \"\"\"\n    Coordinates visual and audio alerts for TIER 2 frontend integration\n    \n    This class serves as the main interface between AI threat detection\n    and the professional frontend alert components (BlinkingBorderOverlay,\n    AlertManager, AudioAlertController, VoiceResponsePanel).\n    \"\"\"\n    \n    def __init__(self, websocket_client=None, config: Dict[str, Any] = None):\n        \"\"\"\n        Initialize the TIER 2 alert coordinator\n        \n        Args:\n            websocket_client: Socket.io client for frontend communication\n            config: Configuration dictionary\n        \"\"\"\n        self.websocket_client = websocket_client\n        self.config = config or {}\n        \n        # Initialize alert engines\n        self.visual_engine = EnhancedVisualAlertEngine(\n            websocket_client=websocket_client,\n            config=self.config.get('visual', {})\n        )\n        \n        self.audio_engine = SpatialAudioEngine(\n            websocket_client=websocket_client,\n            config=self.config.get('audio', {})\n        )\n        \n        # Alert coordination settings\n        self.enable_visual_alerts = self.config.get('enable_visual', True)\n        self.enable_audio_alerts = self.config.get('enable_audio', True)\n        self.enable_voice_responses = self.config.get('enable_voice', True)\n        \n        # Threat escalation configuration\n        self.escalation_rules = {\n            'weapon_detection': {\n                'auto_escalate': True,\n                'escalation_delay': 0,  # Immediate\n                'notify_authorities': True,\n                'trigger_voice_response': True\n            },\n            'violence_detection': {\n                'auto_escalate': True,\n                'escalation_delay': 2000,  # 2 seconds\n                'notify_authorities': True,\n                'trigger_voice_response': True\n            },\n            'trespassing': {\n                'auto_escalate': False,\n                'escalation_delay': 5000,  # 5 seconds\n                'notify_authorities': False,\n                'trigger_voice_response': True\n            },\n            'package_theft': {\n                'auto_escalate': False,\n                'escalation_delay': 3000,  # 3 seconds\n                'notify_authorities': False,\n                'trigger_voice_response': True\n            }\n        }\n        \n        # Statistics and monitoring\n        self.stats = {\n            'total_alerts_coordinated': 0,\n            'visual_alerts_triggered': 0,\n            'audio_alerts_triggered': 0,\n            'voice_responses_initiated': 0,\n            'escalations_performed': 0,\n            'average_response_latency': 0.0,\n            'last_alert_time': None\n        }\n        \n        logger.info('🚨 TIER 2 Alert Coordinator initialized')\n    \n    async def trigger_coordinated_alert(self, threat_data: Dict[str, Any]) -> Dict[str, str]:\n        \"\"\"\n        Trigger coordinated visual and audio alerts for a detected threat\n        \n        Args:\n            threat_data: Comprehensive threat detection data\n        \n        Returns:\n            Dictionary containing alert IDs for tracking\n        \"\"\"\n        start_time = time.time()\n        \n        # Extract threat information\n        zone_id = threat_data.get('zone_id', 'UNKNOWN')\n        threat_type = threat_data.get('threat_type', 'unknown')\n        threat_level = threat_data.get('threat_level', 'MEDIUM')\n        confidence = threat_data.get('confidence', 75)\n        description = threat_data.get('description', f'{threat_type} detected')\n        bbox = threat_data.get('bbox', (0, 0, 100, 100))\n        engines_triggered = threat_data.get('engines_triggered', [])\n        \n        # Convert zone bounding box to position for spatial audio\n        zone_position = self._bbox_to_position(bbox, zone_id)\n        \n        # Enhanced threat data for engines\n        enhanced_threat_data = {\n            **threat_data,\n            'zone_position': zone_position,\n            'coordination_timestamp': datetime.now().isoformat(),\n            'coordinator_id': f'tier2_coord_{int(time.time() * 1000)}'\n        }\n        \n        alert_ids = {}\n        \n        try:\n            # Trigger visual alert\n            if self.enable_visual_alerts:\n                visual_alert_id = await self.visual_engine.trigger_visual_alert(\n                    zone_id=zone_id,\n                    threat_data=enhanced_threat_data\n                )\n                alert_ids['visual'] = visual_alert_id\n                self.stats['visual_alerts_triggered'] += 1\n                logger.info(f'✨ Visual alert triggered: {visual_alert_id}')\n            \n            # Trigger spatial audio alert\n            if self.enable_audio_alerts:\n                audio_alert_id = await self.audio_engine.trigger_spatial_alert(\n                    alert_data=enhanced_threat_data\n                )\n                alert_ids['audio'] = audio_alert_id\n                self.stats['audio_alerts_triggered'] += 1\n                logger.info(f'🔊 Audio alert triggered: {audio_alert_id}')\n            \n            # Check for voice response triggers\n            if self.enable_voice_responses and self._should_trigger_voice_response(threat_data):\n                voice_response_id = await self._trigger_voice_response(enhanced_threat_data)\n                if voice_response_id:\n                    alert_ids['voice'] = voice_response_id\n                    self.stats['voice_responses_initiated'] += 1\n                    logger.info(f'🗣️ Voice response triggered: {voice_response_id}')\n            \n            # Check for automatic escalation\n            if self._should_auto_escalate(threat_data):\n                escalation_id = await self._handle_threat_escalation(enhanced_threat_data)\n                if escalation_id:\n                    alert_ids['escalation'] = escalation_id\n                    self.stats['escalations_performed'] += 1\n                    logger.warning(f'🔥 Threat escalated: {escalation_id}')\n            \n            # Update coordination statistics\n            response_time = time.time() - start_time\n            self._update_coordination_stats(response_time)\n            \n            logger.info(f'🚨 Coordinated alert complete: {zone_id} - {threat_level} ({response_time:.3f}s)')\n            \n        except Exception as e:\n            logger.error(f'❌ Coordinated alert failed: {e}')\n            alert_ids['error'] = str(e)\n        \n        return alert_ids\n    \n    def _bbox_to_position(self, bbox: tuple, zone_id: str) -> Dict[str, float]:\n        \"\"\"\n        Convert bounding box to normalized zone position\n        \n        Args:\n            bbox: Bounding box (x, y, width, height)\n            zone_id: Zone identifier for fallback positioning\n        \n        Returns:\n            Normalized position {x: 0.0-1.0, y: 0.0-1.0}\n        \"\"\"\n        try:\n            x, y, width, height = bbox\n            \n            # Calculate center point of bounding box\n            center_x = x + width / 2\n            center_y = y + height / 2\n            \n            # Normalize to 0.0-1.0 range (assuming screen coordinates)\n            # This would typically use actual screen resolution\n            screen_width = 1920  # Default assumption\n            screen_height = 1080\n            \n            norm_x = max(0.0, min(1.0, center_x / screen_width))\n            norm_y = max(0.0, min(1.0, center_y / screen_height))\n            \n            return {'x': norm_x, 'y': norm_y}\n            \n        except Exception:\n            # Fallback to zone-based positioning\n            zone_positions = {\n                'CAM-01': {'x': 0.2, 'y': 0.2},  # Front entrance\n                'CAM-02': {'x': 0.8, 'y': 0.2},  # Parking lot\n                'CAM-03': {'x': 0.2, 'y': 0.8},  # Lobby\n                'CAM-04': {'x': 0.8, 'y': 0.8},  # Rear exit\n                'DEFAULT': {'x': 0.5, 'y': 0.5}  # Center\n            }\n            \n            return zone_positions.get(zone_id, zone_positions['DEFAULT'])\n    \n    def _should_trigger_voice_response(self, threat_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Determine if a voice response should be triggered\n        \n        Args:\n            threat_data: Threat detection data\n        \n        Returns:\n            True if voice response should be triggered\n        \"\"\"\n        threat_type = threat_data.get('threat_type', '').lower()\n        threat_level = threat_data.get('threat_level', 'MEDIUM')\n        confidence = threat_data.get('confidence', 0)\n        \n        # High confidence and threat level triggers\n        if confidence >= 80 and threat_level in ['HIGH', 'CRITICAL', 'WEAPON']:\n            return True\n        \n        # Specific threat types that warrant voice response\n        voice_trigger_threats = [\n            'trespassing', 'weapon_detection', 'violence_detection',\n            'package_theft', 'vandalism', 'loitering'\n        ]\n        \n        return any(trigger in threat_type for trigger in voice_trigger_threats)\n    \n    def _should_auto_escalate(self, threat_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Determine if threat should be automatically escalated\n        \n        Args:\n            threat_data: Threat detection data\n        \n        Returns:\n            True if threat should be escalated\n        \"\"\"\n        threat_type = threat_data.get('threat_type', '').lower()\n        threat_level = threat_data.get('threat_level', 'MEDIUM')\n        \n        # Check escalation rules\n        for threat_pattern, rules in self.escalation_rules.items():\n            if threat_pattern in threat_type and rules.get('auto_escalate', False):\n                return True\n        \n        # Always escalate weapon and critical threats\n        return threat_level in ['WEAPON', 'CRITICAL']\n    \n    async def _trigger_voice_response(self, threat_data: Dict[str, Any]) -> Optional[str]:\n        \"\"\"\n        Trigger AI voice response for threat de-escalation\n        \n        Args:\n            threat_data: Enhanced threat data\n        \n        Returns:\n            Voice response ID if triggered\n        \"\"\"\n        if not self.websocket_client:\n            logger.warning('⚠️ No websocket client for voice response')\n            return None\n        \n        try:\n            # Select appropriate script based on threat type\n            threat_type = threat_data.get('threat_type', '').lower()\n            script_mapping = {\n                'trespassing': 'TRESPASSING',\n                'package_theft': 'PACKAGE_THEFT',\n                'weapon_detection': 'WEAPON_DETECTED',\n                'violence_detection': 'DE_ESCALATION',\n                'vandalism': 'FINAL_WARNING',\n                'loitering': 'GREETING'\n            }\n            \n            script_id = None\n            for threat_key, script_name in script_mapping.items():\n                if threat_key in threat_type:\n                    script_id = script_name\n                    break\n            \n            # Voice response data\n            voice_data = {\n                'conversation_id': f'voice_{threat_data.get(\"zone_id\")}_{int(time.time() * 1000)}',\n                'zone_id': threat_data.get('zone_id'),\n                'threat_type': threat_data.get('threat_type'),\n                'threat_level': threat_data.get('threat_level'),\n                'script_id': script_id,\n                'auto_triggered': True,\n                'timestamp': datetime.now().isoformat()\n            }\n            \n            # Send voice response trigger to frontend\n            await self.websocket_client.send_message('ai_conversation_started', voice_data)\n            \n            logger.info(f'🗣️ Voice response initiated for {threat_data.get(\"zone_id\")} with script {script_id}')\n            \n            return voice_data['conversation_id']\n            \n        except Exception as e:\n            logger.error(f'❌ Voice response trigger failed: {e}')\n            return None\n    \n    async def _handle_threat_escalation(self, threat_data: Dict[str, Any]) -> Optional[str]:\n        \"\"\"\n        Handle automatic threat escalation procedures\n        \n        Args:\n            threat_data: Enhanced threat data\n        \n        Returns:\n            Escalation ID if performed\n        \"\"\"\n        escalation_id = f'escalation_{int(time.time() * 1000)}'\n        \n        try:\n            threat_type = threat_data.get('threat_type', '').lower()\n            escalation_rules = None\n            \n            # Find matching escalation rules\n            for threat_pattern, rules in self.escalation_rules.items():\n                if threat_pattern in threat_type:\n                    escalation_rules = rules\n                    break\n            \n            if not escalation_rules:\n                return None\n            \n            # Apply escalation delay if specified\n            delay = escalation_rules.get('escalation_delay', 0)\n            if delay > 0:\n                await asyncio.sleep(delay / 1000)  # Convert to seconds\n            \n            escalation_data = {\n                'escalation_id': escalation_id,\n                'original_threat': threat_data,\n                'escalation_rules': escalation_rules,\n                'escalated_at': datetime.now().isoformat(),\n                'notify_authorities': escalation_rules.get('notify_authorities', False),\n                'priority': 'HIGH'\n            }\n            \n            # Send escalation notification to frontend\n            if self.websocket_client:\n                await self.websocket_client.send_message('threat_escalation', escalation_data)\n            \n            logger.warning(f'🔥 Threat escalated: {escalation_id} for {threat_data.get(\"zone_id\")}')\n            \n            return escalation_id\n            \n        except Exception as e:\n            logger.error(f'❌ Threat escalation failed: {e}')\n            return None\n    \n    def _update_coordination_stats(self, response_time: float):\n        \"\"\"\n        Update coordination performance statistics\n        \n        Args:\n            response_time: Time taken for coordination\n        \"\"\"\n        self.stats['total_alerts_coordinated'] += 1\n        self.stats['last_alert_time'] = datetime.now().isoformat()\n        \n        # Update rolling average response time\n        total_alerts = self.stats['total_alerts_coordinated']\n        current_avg = self.stats['average_response_latency']\n        \n        new_avg = ((current_avg * (total_alerts - 1)) + response_time) / total_alerts\n        self.stats['average_response_latency'] = new_avg\n    \n    async def register_zone(self, zone_id: str, monitor_id: str, \n                           position: Dict[str, int], zone_config: Dict[str, Any] = None):\n        \"\"\"\n        Register a monitoring zone with both alert engines\n        \n        Args:\n            zone_id: Unique zone identifier\n            monitor_id: Monitor identifier\n            position: Zone position {x, y, width, height}\n            zone_config: Additional zone configuration\n        \"\"\"\n        # Register with visual engine\n        self.visual_engine.register_zone(zone_id, monitor_id, position, zone_config)\n        \n        logger.info(f'📍 Zone {zone_id} registered with TIER 2 coordinator')\n    \n    async def clear_zone_alerts(self, zone_id: str) -> Dict[str, bool]:\n        \"\"\"\n        Clear all alerts for a specific zone\n        \n        Args:\n            zone_id: Zone to clear\n        \n        Returns:\n            Dictionary showing which engines cleared alerts\n        \"\"\"\n        results = {}\n        \n        # Clear visual alerts\n        results['visual'] = await self.visual_engine.clear_visual_alert(zone_id)\n        \n        # Audio alerts are automatically managed by expiration\n        results['audio'] = True\n        \n        logger.info(f'🧹 Cleared alerts for zone {zone_id}')\n        \n        return results\n    \n    async def clear_all_alerts(self):\n        \"\"\"\n        Clear all active alerts from both engines\n        \"\"\"\n        await self.visual_engine.clear_all_visual_alerts()\n        await self.audio_engine.stop_all_audio_alerts()\n        \n        logger.info('🧹 All TIER 2 alerts cleared')\n    \n    def get_coordination_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get comprehensive coordination statistics\n        \n        Returns:\n            Combined statistics from all engines\n        \"\"\"\n        visual_stats = self.visual_engine.get_visual_alert_stats()\n        audio_stats = self.audio_engine.get_audio_stats()\n        \n        combined_stats = {\n            'coordinator': self.stats.copy(),\n            'visual_engine': visual_stats,\n            'audio_engine': audio_stats,\n            'system_status': {\n                'visual_alerts_enabled': self.enable_visual_alerts,\n                'audio_alerts_enabled': self.enable_audio_alerts,\n                'voice_responses_enabled': self.enable_voice_responses,\n                'websocket_connected': self.websocket_client is not None\n            },\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        return combined_stats\n    \n    async def send_stats_to_frontend(self):\n        \"\"\"\n        Send comprehensive statistics to frontend\n        \"\"\"\n        if not self.websocket_client:\n            return\n        \n        try:\n            stats = self.get_coordination_stats()\n            \n            # Send visual stats\n            await self.visual_engine.send_visual_stats_to_frontend()\n            \n            # Send audio stats  \n            await self.audio_engine._send_audio_stats_to_frontend()\n            \n            # Send coordination stats\n            await self.websocket_client.send_message('tier2_coordination_stats', stats)\n            \n            logger.debug('📊 TIER 2 coordination stats sent to frontend')\n            \n        except Exception as e:\n            logger.error(f'❌ Failed to send coordination stats: {e}')\n    \n    def set_websocket_client(self, websocket_client):\n        \"\"\"\n        Update websocket client for all engines\n        \n        Args:\n            websocket_client: Socket.io client instance\n        \"\"\"\n        self.websocket_client = websocket_client\n        self.visual_engine.set_websocket_client(websocket_client)\n        self.audio_engine.set_websocket_client(websocket_client)\n        \n        logger.info('🔌 WebSocket client updated for TIER 2 coordinator')\n    \n    def update_configuration(self, new_config: Dict[str, Any]):\n        \"\"\"\n        Update coordinator configuration\n        \n        Args:\n            new_config: New configuration parameters\n        \"\"\"\n        self.config.update(new_config)\n        \n        # Update feature flags\n        self.enable_visual_alerts = new_config.get('enable_visual', self.enable_visual_alerts)\n        self.enable_audio_alerts = new_config.get('enable_audio', self.enable_audio_alerts)\n        self.enable_voice_responses = new_config.get('enable_voice', self.enable_voice_responses)\n        \n        # Update escalation rules\n        if 'escalation_rules' in new_config:\n            self.escalation_rules.update(new_config['escalation_rules'])\n        \n        logger.info('✅ TIER 2 coordinator configuration updated')\n    \n    def cleanup_expired_alerts(self):\n        \"\"\"\n        Clean up expired alerts from all engines\n        \"\"\"\n        self.visual_engine.cleanup_expired_alerts()\n        self.audio_engine.cleanup_expired_alerts()\n    \n    def __del__(self):\n        \"\"\"Cleanup when coordinator is destroyed\"\"\"\n        try:\n            asyncio.create_task(self.clear_all_alerts())\n        except:\n            pass"