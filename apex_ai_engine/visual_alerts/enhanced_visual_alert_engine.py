"""
APEX AI ENHANCED VISUAL ALERT ENGINE - TIER 2 INTEGRATION
=========================================================
Enhanced visual alert system integrated with frontend TIER 2 components
Generates real-time visual alerts and communicates with React frontend via Socket.io

Features:
- Integration with BlinkingBorderOverlay components
- Real-time Socket.io communication
- Professional threat level mapping
- Multi-zone alert coordination
- Performance optimized rendering
- Frontend-compatible data formats
"""

import asyncio
import json
import time
import math
import threading
from typing import Dict, List, Tuple, Optional, Any
from datetime import datetime, timedelta
from collections import defaultdict, deque
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class ThreatLevel(Enum):
    """Threat level definitions matching frontend ThreatLevels"""
    SAFE = 'SAFE'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    CRITICAL = 'CRITICAL'
    WEAPON = 'WEAPON'

class AlertPattern(Enum):
    """Visual alert pattern types matching frontend animations"""
    SAFE = 'safe'
    LOW_PULSE = 'low_pulse'
    MEDIUM_BLINK = 'medium_blink'
    HIGH_FLASH = 'high_flash'
    CRITICAL_STROBE = 'critical_strobe'
    WEAPON_URGENT = 'weapon_urgent'

class EnhancedVisualAlertEngine:
    """
    Enhanced visual alert engine with frontend integration
    
    Manages visual alerts and communicates with React frontend components
    via Socket.io for real-time threat visualization.
    """
    
    def __init__(self, websocket_client=None, config: Dict[str, Any] = None):\n        \"\"\"\n        Initialize the enhanced visual alert engine\n        \n        Args:\n            websocket_client: Socket.io client for frontend communication\n            config: Configuration dictionary\n        \"\"\"\n        self.websocket_client = websocket_client\n        self.config = config or {}\n        \n        # Alert state management\n        self.active_alerts = {}  # zone_id -> alert_data\n        self.alert_history = deque(maxlen=1000)\n        self.frame_count = 0\n        \n        # Frontend-compatible threat level mapping\n        self.threat_level_mapping = {\n            ThreatLevel.SAFE: {\n                'color': '#00FF88',\n                'intensity': 0.6,\n                'pattern': AlertPattern.SAFE,\n                'priority': 1,\n                'audio_volume': 0.3,\n                'timeout': 5000\n            },\n            ThreatLevel.LOW: {\n                'color': '#FFD700',\n                'intensity': 0.7,\n                'pattern': AlertPattern.LOW_PULSE,\n                'priority': 2,\n                'audio_volume': 0.5,\n                'timeout': 10000\n            },\n            ThreatLevel.MEDIUM: {\n                'color': '#FF8C00',\n                'intensity': 0.8,\n                'pattern': AlertPattern.MEDIUM_BLINK,\n                'priority': 4,\n                'audio_volume': 0.7,\n                'timeout': 15000\n            },\n            ThreatLevel.HIGH: {\n                'color': '#FF4444',\n                'intensity': 0.9,\n                'pattern': AlertPattern.HIGH_FLASH,\n                'priority': 8,\n                'audio_volume': 0.85,\n                'timeout': 30000\n            },\n            ThreatLevel.CRITICAL: {\n                'color': '#FF0033',\n                'intensity': 1.0,\n                'pattern': AlertPattern.CRITICAL_STROBE,\n                'priority': 16,\n                'audio_volume': 0.95,\n                'timeout': 60000\n            },\n            ThreatLevel.WEAPON: {\n                'color': '#8B0000',\n                'intensity': 1.2,\n                'pattern': AlertPattern.WEAPON_URGENT,\n                'priority': 32,\n                'audio_volume': 1.0,\n                'timeout': 120000\n            }\n        }\n        \n        # Zone and monitor management\n        self.registered_zones = {}  # zone_id -> zone_config\n        self.monitor_zones = defaultdict(list)  # monitor_id -> [zone_ids]\n        \n        # Performance tracking\n        self.stats = {\n            'alerts_triggered': 0,\n            'alerts_cleared': 0,\n            'active_alert_count': 0,\n            'peak_alert_count': 0,\n            'average_response_time': 0.0,\n            'frontend_messages_sent': 0\n        }\n        \n        # Thread safety\n        self._lock = threading.Lock()\n        \n        logger.info('ðŸŽ¨ Enhanced Visual Alert Engine initialized with frontend integration')\n    \n    def register_zone(self, zone_id: str, monitor_id: str, \n                     position: Dict[str, int], zone_config: Dict[str, Any] = None):\n        \"\"\"\n        Register a monitoring zone for visual alerts\n        \n        Args:\n            zone_id: Unique zone identifier (e.g., 'CAM-01')\n            monitor_id: Monitor identifier\n            position: Zone position {x, y, width, height}\n            zone_config: Additional zone configuration\n        \"\"\"\n        with self._lock:\n            self.registered_zones[zone_id] = {\n                'zone_id': zone_id,\n                'monitor_id': monitor_id,\n                'position': position,\n                'config': zone_config or {},\n                'registered_time': datetime.now(),\n                'alert_count': 0,\n                'last_alert_time': None\n            }\n            \n            self.monitor_zones[monitor_id].append(zone_id)\n            \n        logger.info(f'ðŸ“ Registered zone {zone_id} on monitor {monitor_id} at {position}')\n    \n    async def trigger_visual_alert(self, zone_id: str, threat_data: Dict[str, Any]) -> str:\n        \"\"\"\n        Trigger a visual alert and send to frontend\n        \n        Args:\n            zone_id: Zone where threat was detected\n            threat_data: Threat detection information\n        \n        Returns:\n            str: Alert ID\n        \"\"\"\n        alert_id = f'alert_{zone_id}_{int(time.time() * 1000)}'\n        \n        # Extract and validate threat data\n        threat_type = threat_data.get('type', 'Unknown Threat')\n        threat_level_str = threat_data.get('threat_level', 'MEDIUM')\n        confidence = max(0, min(100, threat_data.get('confidence', 75)))\n        description = threat_data.get('description', f'{threat_type} detected')\n        engines_triggered = threat_data.get('engines_triggered', [])\n        \n        # Convert threat level string to enum\n        try:\n            threat_level = ThreatLevel(threat_level_str)\n        except ValueError:\n            threat_level = ThreatLevel.MEDIUM\n            logger.warning(f'âš ï¸ Invalid threat level {threat_level_str}, defaulting to MEDIUM')\n        \n        # Get zone configuration\n        zone_config = self.registered_zones.get(zone_id, {})\n        if not zone_config:\n            logger.error(f'âŒ Zone {zone_id} not registered, cannot trigger alert')\n            return alert_id\n        \n        # Get threat level properties\n        level_config = self.threat_level_mapping.get(threat_level, self.threat_level_mapping[ThreatLevel.MEDIUM])\n        \n        # Create alert data\n        alert_data = {\n            'alert_id': alert_id,\n            'zone_id': zone_id,\n            'threat_type': threat_type,\n            'threat_level': threat_level.value,\n            'confidence': confidence,\n            'description': description,\n            'engines_triggered': engines_triggered,\n            'timestamp': datetime.now().isoformat(),\n            'position': zone_config['position'],\n            'monitor_id': zone_config['monitor_id'],\n            'level_config': level_config,\n            'is_active': True,\n            'created_at': time.time()\n        }\n        \n        with self._lock:\n            # Check if zone already has an active alert\n            existing_alert = self.active_alerts.get(zone_id)\n            if existing_alert:\n                # Escalate if higher priority\n                existing_priority = self.threat_level_mapping[ThreatLevel(existing_alert['threat_level'])]['priority']\n                new_priority = level_config['priority']\n                \n                if new_priority > existing_priority:\n                    logger.warning(f'ðŸ”¥ ESCALATING alert in {zone_id}: {threat_level.value}')\n                    self.active_alerts[zone_id] = alert_data\n                else:\n                    # Update existing alert confidence\n                    existing_alert['confidence'] = max(existing_alert['confidence'], confidence)\n                    existing_alert['description'] = description\n                    alert_data = existing_alert\n            else:\n                # New alert\n                self.active_alerts[zone_id] = alert_data\n                logger.warning(f'ðŸš¨ NEW visual alert: {threat_type} in {zone_id} ({threat_level.value})')\n            \n            # Update statistics\n            self.stats['alerts_triggered'] += 1\n            self.stats['active_alert_count'] = len(self.active_alerts)\n            self.stats['peak_alert_count'] = max(self.stats['peak_alert_count'], len(self.active_alerts))\n            \n            # Update zone statistics\n            if zone_id in self.registered_zones:\n                self.registered_zones[zone_id]['alert_count'] += 1\n                self.registered_zones[zone_id]['last_alert_time'] = datetime.now()\n        \n        # Send to frontend via Socket.io\n        await self._send_visual_alert_to_frontend(alert_data)\n        \n        # Schedule automatic cleanup\n        timeout = level_config['timeout']\n        asyncio.create_task(self._schedule_alert_cleanup(alert_id, zone_id, timeout))\n        \n        return alert_id\n    \n    async def _send_visual_alert_to_frontend(self, alert_data: Dict[str, Any]):\n        \"\"\"\n        Send visual alert data to frontend components\n        \n        Args:\n            alert_data: Alert data to send\n        \"\"\"\n        if not self.websocket_client:\n            logger.warning('âš ï¸ No websocket client available for frontend communication')\n            return\n        \n        # Format data for frontend BlinkingBorderOverlay component\n        frontend_alert = {\n            'alert_id': alert_data['alert_id'],\n            'zone_id': alert_data['zone_id'],\n            'threat_type': alert_data['threat_type'],\n            'threat_level': alert_data['threat_level'],\n            'confidence': alert_data['confidence'],\n            'position': alert_data['position'],\n            'timestamp': alert_data['timestamp'],\n            'custom_label': alert_data.get('description'),\n            'monitor_id': alert_data.get('monitor_id', 0),\n            'overlay_data': {\n                'color': alert_data['level_config']['color'],\n                'intensity': alert_data['level_config']['intensity'],\n                'pattern': alert_data['level_config']['pattern'].value\n            }\n        }\n        \n        try:\n            # Send visual alert event\n            await self.websocket_client.send_message('visual_alert', frontend_alert)\n            \n            # Also send as general threat alert for AlertManager\n            threat_alert = {\n                'alert_type': 'visual',\n                'threat_level': alert_data['threat_level'],\n                'zone_id': alert_data['zone_id'],\n                'camera_id': alert_data['zone_id'],\n                'description': alert_data['description'],\n                'confidence': alert_data['confidence'],\n                'engines_triggered': alert_data['engines_triggered'],\n                'timestamp': alert_data['timestamp']\n            }\n            \n            await self.websocket_client.send_message('threat_alert', threat_alert)\n            \n            self.stats['frontend_messages_sent'] += 1\n            \n            logger.info(f'ðŸ“¤ Visual alert sent to frontend: {alert_data[\"zone_id\"]} - {alert_data[\"threat_level\"]}')\n            \n        except Exception as e:\n            logger.error(f'âŒ Failed to send visual alert to frontend: {e}')\n    \n    async def clear_visual_alert(self, zone_id: str) -> bool:\n        \"\"\"\n        Clear a visual alert for a specific zone\n        \n        Args:\n            zone_id: Zone to clear alert for\n        \n        Returns:\n            bool: True if alert was cleared\n        \"\"\"\n        with self._lock:\n            if zone_id in self.active_alerts:\n                alert_data = self.active_alerts[zone_id]\n                alert_data['is_active'] = False\n                alert_data['cleared_at'] = time.time()\n                \n                del self.active_alerts[zone_id]\n                \n                self.stats['alerts_cleared'] += 1\n                self.stats['active_alert_count'] = len(self.active_alerts)\n                \n                logger.info(f'âœ… Cleared visual alert for zone {zone_id}')\n                \n                # Send clear message to frontend\n                if self.websocket_client:\n                    asyncio.create_task(self._send_clear_alert_to_frontend(zone_id))\n                \n                return True\n        \n        return False\n    \n    async def _send_clear_alert_to_frontend(self, zone_id: str):\n        \"\"\"\n        Send alert clear message to frontend\n        \n        Args:\n            zone_id: Zone to clear\n        \"\"\"\n        try:\n            await self.websocket_client.send_message('clear_visual_alerts', {\n                'zoneId': zone_id,\n                'timestamp': datetime.now().isoformat()\n            })\n            \n            logger.info(f'ðŸ“¤ Clear alert sent to frontend for zone {zone_id}')\n            \n        except Exception as e:\n            logger.error(f'âŒ Failed to send clear alert to frontend: {e}')\n    \n    async def clear_all_visual_alerts(self):\n        \"\"\"\n        Clear all active visual alerts\n        \"\"\"\n        cleared_zones = []\n        \n        with self._lock:\n            for zone_id in list(self.active_alerts.keys()):\n                self.active_alerts[zone_id]['is_active'] = False\n                self.active_alerts[zone_id]['cleared_at'] = time.time()\n                cleared_zones.append(zone_id)\n            \n            self.active_alerts.clear()\n            self.stats['alerts_cleared'] += len(cleared_zones)\n            self.stats['active_alert_count'] = 0\n        \n        # Send clear all message to frontend\n        if self.websocket_client and cleared_zones:\n            try:\n                await self.websocket_client.send_message('clear_visual_alerts', {\n                    'timestamp': datetime.now().isoformat()\n                })\n                \n                logger.info(f'ðŸ§¹ Cleared all visual alerts ({len(cleared_zones)} alerts)')\n                \n            except Exception as e:\n                logger.error(f'âŒ Failed to send clear all alerts to frontend: {e}')\n    \n    async def _schedule_alert_cleanup(self, alert_id: str, zone_id: str, timeout_ms: int):\n        \"\"\"\n        Schedule automatic alert cleanup after timeout\n        \n        Args:\n            alert_id: Alert ID\n            zone_id: Zone ID\n            timeout_ms: Timeout in milliseconds\n        \"\"\"\n        await asyncio.sleep(timeout_ms / 1000)\n        \n        # Check if alert is still active\n        with self._lock:\n            if zone_id in self.active_alerts and self.active_alerts[zone_id]['alert_id'] == alert_id:\n                await self.clear_visual_alert(zone_id)\n                logger.info(f'â° Auto-cleared expired alert {alert_id} for zone {zone_id}')\n    \n    def get_active_alerts(self, monitor_id: str = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get currently active visual alerts\n        \n        Args:\n            monitor_id: Filter by monitor ID (optional)\n        \n        Returns:\n            List of active alert data\n        \"\"\"\n        with self._lock:\n            alerts = []\n            \n            for alert_data in self.active_alerts.values():\n                if monitor_id and alert_data.get('monitor_id') != monitor_id:\n                    continue\n                \n                alerts.append(alert_data.copy())\n            \n            return alerts\n    \n    def get_visual_alert_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get visual alert engine statistics\n        \n        Returns:\n            Statistics dictionary\n        \"\"\"\n        with self._lock:\n            stats = self.stats.copy()\n            \n            # Add current state information\n            stats.update({\n                'registered_zones': len(self.registered_zones),\n                'monitored_displays': len(self.monitor_zones),\n                'active_alerts_by_level': self._get_alerts_by_level(),\n                'zone_statistics': self._get_zone_statistics(),\n                'uptime_seconds': time.time() - getattr(self, '_start_time', time.time())\n            })\n            \n            return stats\n    \n    def _get_alerts_by_level(self) -> Dict[str, int]:\n        \"\"\"\n        Get count of active alerts by threat level\n        \n        Returns:\n            Dictionary with threat level counts\n        \"\"\"\n        level_counts = {level.value: 0 for level in ThreatLevel}\n        \n        for alert_data in self.active_alerts.values():\n            threat_level = alert_data['threat_level']\n            if threat_level in level_counts:\n                level_counts[threat_level] += 1\n        \n        return level_counts\n    \n    def _get_zone_statistics(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics for each registered zone\n        \n        Returns:\n            Zone statistics dictionary\n        \"\"\"\n        zone_stats = {}\n        \n        for zone_id, zone_config in self.registered_zones.items():\n            zone_stats[zone_id] = {\n                'alert_count': zone_config['alert_count'],\n                'last_alert_time': zone_config['last_alert_time'].isoformat() if zone_config['last_alert_time'] else None,\n                'is_active': zone_id in self.active_alerts,\n                'monitor_id': zone_config['monitor_id']\n            }\n        \n        return zone_stats\n    \n    async def send_visual_stats_to_frontend(self):\n        \"\"\"\n        Send current visual alert statistics to frontend\n        \"\"\"\n        if not self.websocket_client:\n            return\n        \n        try:\n            stats = self.get_visual_alert_stats()\n            \n            await self.websocket_client.send_message('visual_stats', {\n                'timestamp': datetime.now().isoformat(),\n                'statistics': stats,\n                'active_alerts': self.get_active_alerts()\n            })\n            \n            logger.debug('ðŸ“Š Visual stats sent to frontend')\n            \n        except Exception as e:\n            logger.error(f'âŒ Failed to send visual stats to frontend: {e}')\n    \n    def update_zone_position(self, zone_id: str, new_position: Dict[str, int]):\n        \"\"\"\n        Update the position of a registered zone\n        \n        Args:\n            zone_id: Zone to update\n            new_position: New position {x, y, width, height}\n        \"\"\"\n        with self._lock:\n            if zone_id in self.registered_zones:\n                self.registered_zones[zone_id]['position'] = new_position\n                logger.info(f'ðŸ“ Updated position for zone {zone_id}: {new_position}')\n            else:\n                logger.warning(f'âš ï¸ Cannot update position for unregistered zone {zone_id}')\n    \n    def set_websocket_client(self, websocket_client):\n        \"\"\"\n        Set or update the websocket client for frontend communication\n        \n        Args:\n            websocket_client: Socket.io client instance\n        \"\"\"\n        self.websocket_client = websocket_client\n        logger.info('ðŸ”Œ WebSocket client updated for visual alert engine')\n    \n    def cleanup_expired_alerts(self, max_age_seconds: int = 300):\n        \"\"\"\n        Clean up alerts that have been active for too long\n        \n        Args:\n            max_age_seconds: Maximum age for alerts in seconds (default: 5 minutes)\n        \"\"\"\n        current_time = time.time()\n        expired_zones = []\n        \n        with self._lock:\n            for zone_id, alert_data in self.active_alerts.items():\n                if current_time - alert_data['created_at'] > max_age_seconds:\n                    expired_zones.append(zone_id)\n        \n        # Clear expired alerts\n        for zone_id in expired_zones:\n            asyncio.create_task(self.clear_visual_alert(zone_id))\n        \n        if expired_zones:\n            logger.info(f'ðŸ§¹ Cleaned up {len(expired_zones)} expired visual alerts')\n    \n    def __del__(self):\n        \"\"\"Cleanup when engine is destroyed\"\"\"\n        try:\n            asyncio.create_task(self.clear_all_visual_alerts())\n        except:\n            pass"